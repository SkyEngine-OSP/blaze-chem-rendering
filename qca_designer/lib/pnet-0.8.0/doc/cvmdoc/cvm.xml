<?xml version="1.0"?>
<srcdoc>
<opcode name="iadd" group="Arithmetic operators">
<operation>Add <code>int32</code></operation>

<format>iadd</format>
<dformat>{iadd}</dformat>

<form name="iadd" code="COP_IADD"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical sum of the two values.</description>

<notes>The <i>iadd</i> instruction can also be used to add
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="iadd_ovf" group="Arithmetic operators">
<operation>Add <code>int32</code> with overflow detection</operation>

<format>iadd_ovf</format>
<dformat>{iadd_ovf}</dformat>

<form name="iadd_ovf" code="COP_IADD_OVF"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="iadd_ovf_un" group="Arithmetic operators">
<operation>Add <code>uint32</code> with overflow detection</operation>

<format>iadd_ovf_un</format>
<dformat>{iadd_ovf_un}</dformat>

<form name="iadd_ovf_un" code="COP_IADD_OVF_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide unsigned format, represented
as a value of type <code>uint32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="isub" group="Arithmetic operators">
<operation>Subtract <code>int32</code></operation>

<format>isub</format>
<dformat>{isub}</dformat>

<form name="isub" code="COP_ISUB"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical difference of the two values.</description>

<notes>The <i>isub</i> instruction can also be used to subtract
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="isub_ovf" group="Arithmetic operators">
<operation>Subtract <code>int32</code> with overflow detection</operation>

<format>isub_ovf</format>
<dformat>{isub_ovf}</dformat>

<form name="isub_ovf" code="COP_ISUB_OVF"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="isub_ovf_un" group="Arithmetic operators">
<operation>Subtract <code>uint32</code> with overflow detection</operation>

<format>isub_ovf_un</format>
<dformat>{isub_ovf_un}</dformat>

<form name="isub_ovf_un" code="COP_ISUB_OVF_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide unsigned format, represented
as a value of type <code>uint32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="imul" group="Arithmetic operators">
<operation>Multiply <code>int32</code></operation>

<format>imul</format>

<form name="imul" code="COP_IMUL"/>
<dformat>{imul}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical multiplication of the two values.</description>

<notes>The <i>imul</i> instruction can also be used to multiply
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="imul_ovf" group="Arithmetic operators">
<operation>Multiply <code>int32</code> with overflow detection</operation>

<format>imul_ovf</format>
<dformat>{imul_ovf}</dformat>

<form name="imul_ovf" code="COP_IMUL_OVF"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="imul_ovf_un" group="Arithmetic operators">
<operation>Multiply <code>uint32</code> with overflow detection</operation>

<format>imul_ovf_un</format>
<dformat>{imul_ovf_un}</dformat>

<form name="imul_ovf_un" code="COP_IMUL_OVF_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 32 low-order bits of the true mathematical
result in a sufficiently wide unsigned format, represented
as a value of type <code>uint32</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="idiv" group="Arithmetic operators">
<operation>Divide <code>int32</code></operation>

<format>idiv</format>
<dformat>{idiv}</dformat>

<form name="idiv" code="COP_IDIV"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 / value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
<exception name="System.ArithmeticException">Raised if
<i>value1</i> is -1 and <i>value2</i> is -2147483648.</exception>
</exceptions>
</opcode>
<opcode name="idiv_un" group="Arithmetic operators">
<operation>Divide <code>uint32</code></operation>

<format>idiv_un</format>
<dformat>{idiv_un}</dformat>

<form name="idiv_un" code="COP_IDIV_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>value1 / value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
</exceptions>
</opcode>
<opcode name="irem" group="Arithmetic operators">
<operation>Remainder <code>int32</code></operation>

<format>irem</format>
<dformat>{irem}</dformat>

<form name="irem" code="COP_IREM"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 % value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
<exception name="System.ArithmeticException">Raised if
<i>value1</i> is -1 and <i>value2</i> is -2147483648.</exception>
</exceptions>
</opcode>
<opcode name="irem_un" group="Arithmetic operators">
<operation>Remainder <code>uint32</code></operation>

<format>irem_un</format>
<dformat>{irem_un}</dformat>

<form name="irem_un" code="COP_IREM_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>value1 % value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
</exceptions>
</opcode>
<opcode name="ineg" group="Arithmetic operators">
<operation>Negate <code>int32</code></operation>

<format>ineg</format>
<dformat>{ineg}</dformat>

<form name="ineg" code="COP_INEG"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack
as type <code>int32</code>.  The <code>int32</code> <i>result</i>
is <i>-value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<notes>To perform negation with overflow detection, use
<i>isub_ovf</i> with the first argument set to 0 and the
second argument set to <i>value</i>.</notes>
</opcode>
<opcode name="ladd" group="Arithmetic operators">
<operation>Add <code>int64</code></operation>

<format>ladd</format>

<form name="ladd" code="COP_LADD"/>
<dformat>{ladd}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical sum of the two values.</description>

<notes>The <i>ladd</i> instruction can also be used to add
values of type <code>uint64</code>.<p/>

Values of type <code>int64</code> typically occupy 2 stack slots
on 32-bit machines and 1 stack slot on 64-bit machines, although
this is layout not fixed.  When we say that <i>value1</i> and
<i>value2</i> are popped, we assume that the correct number of
stack slots for the machine are popped.  Similarly when <i>result</i>
is pushed.</notes>
</opcode>
<opcode name="ladd_ovf" group="Arithmetic operators">
<operation>Add <code>int64</code> with overflow detection</operation>

<format>ladd_ovf</format>
<dformat>{ladd_ovf}</dformat>

<form name="ladd_ovf" code="COP_LADD_OVF"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int64</code>.</exception>
</exceptions>
</opcode>
<opcode name="ladd_ovf_un" group="Arithmetic operators">
<operation>Add <code>uint64</code> with overflow detection</operation>

<format>ladd_ovf_un</format>
<dformat>{ladd_ovf_un}</dformat>

<form name="ladd_ovf_un" code="COP_LADD_OVF_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>uint64</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide unsignedcomplement format, represented
as a value of type <code>uint64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="lsub" group="Arithmetic operators">
<operation>Subtract <code>int64</code></operation>

<format>lsub</format>
<dformat>{lsub}</dformat>

<form name="lsub" code="COP_LSUB"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical difference of the two values.</description>

<notes>The <i>lsub</i> instruction can also be used to subtract
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lsub_ovf" group="Arithmetic operators">
<operation>Subtract <code>int64</code> with overflow detection</operation>

<format>lsub_ovf</format>
<dformat>{lsub_ovf}</dformat>

<form name="lsub_ovf" code="COP_LSUB_OVF"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int64</code>.</exception>
</exceptions>
</opcode>
<opcode name="lsub_ovf_un" group="Arithmetic operators">
<operation>Subtract <code>uint64</code> with overflow detection</operation>

<format>lsub_ovf_un</format>
<dformat>{lsub_ovf_un}</dformat>

<form name="lsub_ovf_un" code="COP_LSUB_OVF_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>uint64</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide unsignedcomplement format, represented
as a value of type <code>uint64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="lmul" group="Arithmetic operators">
<operation>Multiply <code>int64</code></operation>

<format>lmul</format>
<dformat>{lmul}</dformat>

<form name="lmul" code="COP_LMUL"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
the sign of the result may not be the same as the sign of the
mathematical multiplication of the two values.</description>

<notes>The <i>lmul</i> instruction can also be used to multiply
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lmul_ovf" group="Arithmetic operators">
<operation>Multiply <code>int64</code> with overflow detection</operation>

<format>lmul_ovf</format>

<form name="lmul_ovf" code="COP_LMUL_OVF"/>
<dformat>{lmul_ovf}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide two's-complement format, represented
as a value of type <code>int64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>int64</code>.</exception>
</exceptions>
</opcode>
<opcode name="lmul_ovf_un" group="Arithmetic operators">
<operation>Multiply <code>uint64</code> with overflow detection</operation>

<format>lmul_ovf_un</format>

<form name="lmul_ovf_un" code="COP_LMUL_OVF_UN"/>
<dformat>{lmul_ovf_un}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>uint64</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.<p/>

The result is the 64 low-order bits of the true mathematical
result in a sufficiently wide unsignedcomplement format, represented
as a value of type <code>uint64</code>.  If overflow occurs, then
<code>System.OverflowException</code> is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if
the true mathemetical result is too large to be represented
as a value of type <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="ldiv" group="Arithmetic operators">
<operation>Divide <code>int64</code></operation>

<format>ldiv</format>
<dformat>{ldiv}</dformat>

<form name="ldiv" code="COP_LDIV"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 / value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
<exception name="System.ArithmeticException">Raised if
<i>value1</i> is -1 and <i>value2</i> is -9223372036854775808.
</exception>
</exceptions>
</opcode>
<opcode name="ldiv_un" group="Arithmetic operators">
<operation>Divide <code>uint64</code></operation>

<format>ldiv_un</format>
<dformat>{ldiv_un}</dformat>

<form name="ldiv_un" code="COP_LDIV_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>uint64</code> <i>result</i> is <i>value1 / value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
</exceptions>
</opcode>
<opcode name="lrem" group="Arithmetic operators">
<operation>Remainder <code>int64</code></operation>

<format>lrem</format>
<dformat>{lrem}</dformat>

<form name="lrem" code="COP_LREM"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 % value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
<exception name="System.ArithmeticException">Raised if
<i>value1</i> is -1 and <i>value2</i> is -9223372036854775808.
</exception>
</exceptions>
</opcode>
<opcode name="lrem_un" group="Arithmetic operators">
<operation>Remainder <code>uint64</code></operation>

<format>lrem_un</format>
<dformat>{lrem_un}</dformat>

<form name="lrem_un" code="COP_LREM_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>uint64</code> <i>result</i> is <i>value1 % value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.DivideByZeroException">Raised if
<i>value2</i> is zero.</exception>
</exceptions>
</opcode>
<opcode name="lneg" group="Arithmetic operators">
<operation>Negate <code>int64</code></operation>

<format>lneg</format>
<dformat>{lneg}</dformat>

<form name="lneg" code="COP_LNEG"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack
as type <code>int64</code>.  The <code>int64</code> <i>result</i>
is <i>-value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<notes>To perform negation with overflow detection, use
<i>lsub_ovf</i> with the first argument set to 0 and the
second argument set to <i>value</i>.</notes>
</opcode>
<opcode name="fadd" group="Arithmetic operators">
<operation>Add <code>native float</code></operation>

<format>fadd</format>
<dformat>{fadd}</dformat>

<form name="fadd" code="COP_FADD"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>native float</code> <i>result</i> is <i>value1 + value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>Values of type <code>native float</code> typically occupy
multiple stack slots.  The exact number of slots is machine-dependent,
as is the precision of the <code>native float</code> type.<p/>

When we say that <i>value1</i> and <i>value2</i> are popped,
we assume that the correct number of stack slots for the machine
are popped.  Similarly when <i>result</i> is pushed.<p/>

To perform strict 32-bit floating point addition, use <i>fadd</i>
followed by <i>f2f</i>.  To perform strict 64-bit floating point
addition, use <i>fadd</i> followed by <i>f2d</i>.</notes>
</opcode>
<opcode name="fsub" group="Arithmetic operators">
<operation>Subtract <code>native float</code></operation>

<format>fsub</format>
<dformat>{fsub}</dformat>

<form name="fsub" code="COP_FSUB"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped fr
om the stack as type <code>native float</code>.  The
<code>native float</code> <i>result</i> is <i>value1 - value2</i>.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="fmul" group="Arithmetic operators">
<operation>Multiply <code>native float</code></operation>

<format>fmul</format>
<dformat>{fmul}</dformat>

<form name="fmul" code="COP_FMUL"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>native float</code> <i>result</i> is <i>value1 * value2</i>.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="fdiv" group="Arithmetic operators">
<operation>Divide <code>native float</code></operation>

<format>fdiv</format>
<dformat>{fdiv}</dformat>

<form name="fdiv" code="COP_FDIV"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>native float</code> <i>result</i> is <i>value1 / value2</i>.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="frem" group="Arithmetic operators">
<operation>Remainder <code>native float</code></operation>

<format>frem</format>
<dformat>{frem}</dformat>

<form name="frem" code="COP_FREM"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>native float</code> <i>result</i> is <i>value1 % value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The remainder operation is similar to the C <code>fmod</code>
function, not IEEE remainder.</notes>
</opcode>
<opcode name="fneg" group="Arithmetic operators">
<operation>Negate <code>native float</code></operation>

<format>fneg</format>
<dformat>{fneg}</dformat>

<form name="fneg" code="COP_FNEG"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as type
<code>native float</code>.  The <code>native float</code>
<i>result</i> is <i>-value</i>.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="iand" group="Bitwise operators">
<operation>Bitwise AND <code>int32</code></operation>

<format>iand</format>
<dformat>{iand}</dformat>

<form name="iand" code="COP_IAND"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 &amp; value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>iand</i> instruction can also be used to AND
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="ior" group="Bitwise operators">
<operation>Bitwise OR <code>int32</code></operation>

<format>ior</format>
<dformat>{ior}</dformat>

<form name="ior" code="COP_IOR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 | value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>ior</i> instruction can also be used to OR
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="ixor" group="Bitwise operators">
<operation>Bitwise XOR <code>int32</code></operation>

<format>ixor</format>
<dformat>{ixor}</dformat>

<form name="ixor" code="COP_IXOR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is <i>value1 ^ value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>ixor</i> instruction can also be used to XOR
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="inot" group="Bitwise operators">
<operation>Bitwise NOT <code>int32</code></operation>

<format>inot</format>
<dformat>{inot}</dformat>

<form name="inot" code="COP_INOT"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is <i>~value</i>.  The <i>result</i> is pushed onto the
stack.</description>

<notes>The <i>inot</i> instruction can also be used to NOT
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="ishl" group="Bitwise operators">
<operation>Left shift <code>int32</code></operation>

<format>ishl</format>
<dformat>{ishl}</dformat>

<form name="ishl" code="COP_ISHL"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as the types <code>int32</code>
and <code>uint32</code> respectively.  The <code>int32</code>
<i>result</i> is <i>(value1 &lt;&lt; (value2 &amp; 0x1F))</i>.
Bits that are shifted out the top of <i>value1</i> are discarded.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>ishl</i> instruction can also be used to shift
values of type <code>uint32</code>.</notes>
</opcode>
<opcode name="ishr" group="Bitwise operators">
<operation>Right arithmetic shift <code>int32</code></operation>

<format>ishr</format>
<dformat>{ishr}</dformat>

<form name="ishr" code="COP_ISHR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as the types <code>int32</code>
and <code>uint32</code> respectively.  The <code>int32</code>
<i>result</i> is <i>(value1 &gt;&gt; (value2 &amp; 0x1F))</i>.
The top-most bit of <i>value1</i> is used to fill new bits shifted
in from the top.  The <i>result</i> is pushed onto the
stack.</description>
</opcode>
<opcode name="ishr_un" group="Bitwise operators">
<operation>Right unsigned shift <code>uint32</code></operation>

<format>ishr_un</format>

<form name="ishr_un" code="COP_ISHR_UN"/>
<dformat>{ishr_un}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>uint32</code> <i>result</i> is <i>(value1 &gt;&gt;
(value2 &amp; 0x1F))</i>.  Zeroes are used to fill new
bits shifted in from the top.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="land" group="Bitwise operators">
<operation>Bitwise AND <code>int64</code></operation>

<format>land</format>
<dformat>{land}</dformat>

<form name="land" code="COP_LAND"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 &amp; value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>land</i> instruction can also be used to AND
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lor" group="Bitwise operators">
<operation>Bitwise OR <code>int64</code></operation>

<format>lor</format>
<dformat>{lor}</dformat>

<form name="lor" code="COP_LOR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 | value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>lor</i> instruction can also be used to OR
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lxor" group="Bitwise operators">
<operation>Bitwise XOR <code>int64</code></operation>

<format>lxor</format>

<form name="lxor" code="COP_LXOR"/>
<dformat>{lxor}</dformat>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int64</code> <i>result</i> is <i>value1 ^ value2</i>.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>lxor</i> instruction can also be used to XOR
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lnot" group="Bitwise operators">
<operation>Bitwise NOT <code>int64</code></operation>

<format>lnot</format>
<dformat>{lnot}</dformat>

<form name="lnot" code="COP_LNOT"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>.  The <code>int64</code> <i>result</i>
is <i>~value</i>.  The <i>result</i> is pushed onto the
stack.</description>

<notes>The <i>lnot</i> instruction can also be used to NOT
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lshl" group="Bitwise operators">
<operation>Left shift <code>int64</code></operation>

<format>lshl</format>
<dformat>{lshl}</dformat>

<form name="lshl" code="COP_LSHL"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as the types <code>int64</code>
and <code>uint32</code> respectively.  The <code>int64</code>
<i>result</i> is <i>(value1 &lt;&lt; (value2 &amp; 0x3F))</i>.
Bits that are shifted out the top of <i>value1</i> are discarded.
The <i>result</i> is pushed onto the stack.</description>

<notes>The <i>lshl</i> instruction can also be used to shift
values of type <code>uint64</code>.</notes>
</opcode>
<opcode name="lshr" group="Bitwise operators">
<operation>Right arithmetic shift <code>int64</code></operation>

<format>lshr</format>
<dformat>{lshr}</dformat>

<form name="lshr" code="COP_LSHR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as the types <code>int64</code>
and <code>uint32</code> respectively.  The <code>int64</code>
<i>result</i> is <i>(value1 &gt;&gt; (value2 &amp; 0x3F))</i>.
The top-most bit of <i>value1</i> is used to fill new bits shifted
in from the top.  The <i>result</i> is pushed onto the
stack.</description>
</opcode>
<opcode name="lshr_un" group="Bitwise operators">
<operation>Right unsigned shift <code>uint64</code></operation>

<format>lshr_un</format>
<dformat>{lshr_un}</dformat>

<form name="lshr_un" code="COP_LSHR_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as the types <code>uint64</code>
and <code>uint32</code> respectively.  The <code>uint64</code>
<i>result</i> is <i>(value1 &gt;&gt; (value2 &amp; 0x3F))</i>.
Zeroes are used to fill new bits shifted in from the top.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="ckfinite" group="Arithmetic operators">
<operation>Check <code>native float</code> for finite</operation>

<format>prefix<fsep/>ckfinite</format>
<dformat>{ckfinite}</dformat>

<form name="ckfinite" code="COP_PREFIX_CKFINITE"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as type
<code>native float</code>.  If <i>value</i> is not finite (i.e.
it is NaN, positive infinity, or negative infinity), then
<code>System.ArithmeticException</code> is thrown.</description>

<exceptions>
<exception name="System.ArithmeticException">Raised if
<i>value</i> is not finite.</exception>
</exceptions>
</opcode>
<opcode name="br" group="Branch instructions">
<operation>Branch unconditionally</operation>

<format>br<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>br
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{br}<fsep/>dest</dformat>

<form name="br" code="COP_BR"/>

<before>...</before>
<after>...</after>

<description>In the first form, the program branches to the
address <i>pc + offset</i>, where <i>pc</i> is the address of
the first byte of the <i>br</i> instruction, and <i>offset</i>
is a signed 8-bit quantity.<p/>

In the second form, <i>offset</i> is constructed by interpreting
<i>offset1</i>, ..., <i>offset4</i> as a 32-bit signed quantity
in little-endian order.</description>

<notes>Branch instructions are always 6 bytes long, but may
contain either short or long forms of a branch.  The short form
is always "<i>opcode offset pad</i>" where <i>offset</i> is an
8-bit offset and <i>pad</i> is 4 bytes of padding.  The long form
is always "<i>br.long opcode loffset</i>" where <i>loffset</i>
is a 32-bit offset.  This allows the code generator to output
branch instructions with a uniform length, while the interpreter
runs faster on short branches.</notes>
</opcode>
<opcode name="beq" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are equal</operation>

<format>beq<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>beq
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{beq}<fsep/>dest</dformat>

<form name="beq" code="COP_BEQ"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If the values are equal,
then the program branches to <i>pc + offset</i>.  Otherwise,
the program continues with the next instruction.</description>

<notes>This instruction must not be confused with <i>br_peq</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="bne" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are not equal</operation>

<format>bne<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>bne
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{bne}<fsep/>dest</dformat>

<form name="bne" code="COP_BNE"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If the values are not equal,
then the program branches to <i>pc + offset</i>.  Otherwise,
the program continues with the next instruction.</description>

<notes>This instruction must not be confused with <i>br_pne</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="blt" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are less than</operation>

<format>blt<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>blt
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{blt}<fsep/>dest</dformat>

<form name="blt" code="COP_BLT"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If <i>value1</i> is less
than <i>value2</i>, then the program branches to <i>pc + offset</i>.
Otherwise, the program continues with the next instruction.</description>
</opcode>
<opcode name="blt_un" group="Branch instructions">
<operation>Branch conditionally if <code>uint32</code> values
are less than</operation>

<format>blt_un<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>blt_un
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{blt_un}<fsep/>dest</dformat>

<form name="blt_un" code="COP_BLT_UN"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>uint32</i>.  If <i>value1</i> is less
than <i>value2</i>, then the program branches to <i>pc + offset</i>.
Otherwise, the program continues with the next instruction.</description>
</opcode>
<opcode name="ble" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are less than or equal</operation>

<format>ble<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>ble
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{ble}<fsep/>dest</dformat>

<form name="ble" code="COP_BLE"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If <i>value1</i> is less
than or equal to <i>value2</i>, then the program branches to
<i>pc + offset</i>.  Otherwise, the program continues with the
next instruction.</description>
</opcode>
<opcode name="ble_un" group="Branch instructions">
<operation>Branch conditionally if <code>uint32</code> values
are less than or equal</operation>

<format>ble_un<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>ble_un
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{ble_un}<fsep/>dest</dformat>

<form name="ble_un" code="COP_BLE_UN"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>uint32</i>.  If <i>value1</i> is less
than or equal to <i>value2</i>, then the program branches to
<i>pc + offset</i>.  Otherwise, the program continues with the
next instruction.</description>
</opcode>
<opcode name="bgt" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are greater than</operation>

<format>bgt<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>bgt
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{bgt}<fsep/>dest</dformat>

<form name="bgt" code="COP_BGT"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If <i>value1</i> is greater
than <i>value2</i>, then the program branches to <i>pc + offset</i>.
Otherwise, the program continues with the next instruction.</description>
</opcode>
<opcode name="bgt_un" group="Branch instructions">
<operation>Branch conditionally if <code>uint32</code> values
are greater than</operation>

<format>bgt_un<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>bgt_un
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{bgt_un}<fsep/>dest</dformat>

<form name="bgt_un" code="COP_BGT_UN"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>uint32</i>.  If <i>value1</i> is greater
than <i>value2</i>, then the program branches to <i>pc + offset</i>.
Otherwise, the program continues with the next instruction.</description>
</opcode>
<opcode name="bge" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> values
are greater than or equal</operation>

<format>bge<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>bge
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{bge}<fsep/>dest</dformat>

<form name="bge" code="COP_BGE"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>int32</code>.  If <i>value1</i> is greater
than or equal to <i>value2</i>, then the program branches to
<i>pc + offset</i>.  Otherwise, the program continues with the
next instruction.</description>
</opcode>
<opcode name="bge_un" group="Branch instructions">
<operation>Branch conditionally if <code>uint32</code> values
are greater than or equal</operation>

<format>bge_un<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>bge_un
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{bge_un}<fsep/>dest</dformat>

<form name="bge_un" code="COP_BGE_UN"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>uint32</i>.  If <i>value1</i> is greater
than or equal to <i>value2</i>, then the program branches to
<i>pc + offset</i>.  Otherwise, the program continues with the
next instruction.</description>
</opcode>
<opcode name="brtrue" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> value
is non-zero</operation>

<format>brtrue<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>brtrue
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{brtrue}<fsep/>dest</dformat>

<form name="brtrue" code="COP_BRTRUE"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as type
<code>int32</code>.  If <i>value</i> is non-zero, then the program
branches to <i>pc + offset</i>.  Otherwise, the program continues
with the next instruction.</description>

<notes>This instruction must not be confused with <code>brnonnull</code>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="brfalse" group="Branch instructions">
<operation>Branch conditionally if <code>int32</code> value
is zero</operation>

<format>brfalse<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>brfalse
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{brfalse}<fsep/>dest</dformat>

<form name="brfalse" code="COP_BRFALSE"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as type
<code>int32</code>.  If <i>value</i> is zero, then the program branches
to <i>pc + offset</i>.  Otherwise, the program continues with the
next instruction.</description>

<notes>This instruction must not be confused with <code>brnull</code>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="brnull" group="Branch instructions">
<operation>Branch conditionally if <code>ptr</code> value
is <code>null</code></operation>

<format>brnull<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>brnull
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{brnull}<fsep/>dest</dformat>

<form name="brnull" code="COP_BRNULL"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as type
<i>ptr</i>.  If <i>value</i> is <code>null</code>, then the program
branches to <i>pc + offset</i>.  Otherwise, the program continues
with the next instruction.</description>

<notes>This instruction must not be confused with <code>brfalse</code>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="brnonnull" group="Branch instructions">
<operation>Branch conditionally if <code>ptr</code> value
is not <code>null</code></operation>

<format>brnonnull<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>brnonnull
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{brnonnull}<fsep/>dest</dformat>

<form name="brnonnull" code="COP_BRNONNULL"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as type
<i>ptr</i>.  If <i>value</i> is not <code>null</code>, then the program
branches to <i>pc + offset</i>.  Otherwise, the program continues
with the next instruction.</description>

<notes>This instruction must not be confused with <code>brtrue</code>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="br_peq" group="Branch instructions">
<operation>Branch conditionally if <code>ptr</code> values
are equal</operation>

<format>br_peq<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>br_peq
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{br_peq}<fsep/>dest</dformat>

<form name="br_peq" code="COP_BR_PEQ"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>ptr</i>.  If the values are equal,
then the program branches to <i>pc + offset</i>.  Otherwise,
the program continues with the next instruction.</description>

<notes>This instruction must not be confused with <i>beq</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="br_pne" group="Branch instructions">
<operation>Branch conditionally if <code>ptr</code> values
are not equal</operation>

<format>br_pne<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>br_pne
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{br_pne}<fsep/>dest</dformat>

<form name="br_pne" code="COP_BR_PNE"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <i>ptr</i>.  If the values are not equal,
then the program branches to <i>pc + offset</i>.  Otherwise,
the program continues with the next instruction.</description>

<notes>This instruction must not be confused with <i>bne</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="br_long" group="Branch instructions">
<operation>Modify a branch instruction to its long form</operation>

<format>br_long<fsep/>opcode<fsep/>...</format>

<form name="br_long" code="COP_BR_LONG"/>

<description>The <i>br_long</i> instruction modifies a branch
instruction to take longer operands.</description>

<notes>The documentation for other branch instructions includes
information on their long forms.<p/>

There is no direct format for this instruction, because <i>br_long</i>
is not required for the direct encoding.</notes>
</opcode>
<opcode name="switch" group="Branch instructions">
<operation>Switch on <code>uint32</code> value</operation>

<format>switch<fsep/>max<fsep/>defoffset<fsep/>...</format>
<dformat>{switch}<fsep/>max<fsep/>defaddr<fsep/>...</dformat>

<form name="switch" code="COP_SWITCH"/>

<before>..., value</before>
<after>...</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If it is greater than or equal to
<i>max</i>, then the program continues at <i>pc + defoffset</i>.
Otherwise, the 32-bit signed value at <i>pc + 9 + value * 4</i>
is fetched and added to <i>pc</i>.</description>

<notes>The <i>max</i> value is an unsigned 32-bit value, and
the <i>defoffset</i> is a signed 32-bit value.  All 32-bit
values are in little-endian byte order.</notes>
</opcode>
<opcode name="nop" group="Miscellaneous instructions">
<operation>Do nothing</operation>

<format>nop</format>
<dformat>{nop}</dformat>

<form name="nop" code="COP_NOP"/>

<description>Do nothing.</description>
</opcode>
<opcode name="break" group="Miscellaneous instructions">
<operation>Mark the position of a breakpoint</operation>

<format>break<fsep/>subcode</format>

<dformat>{break}<fsep/>subcode</dformat>

<form name="break" code="COP_BREAK"/>

<description>This instruction marks a position in the
CVM bytecode that may be used as a breakpoint in
debug versions of the runtime engine.<p/>

Every potentional position for a breakpoint is marked,
even if those positions will never have active breakpoints
set on them.  The runtime engine keeps a list of active
breakpoints, which is inspected at each potentional
breakpoint.</description>
</opcode>
<opcode name="wide" group="Miscellaneous instructions">
<operation>Modify an instruction to its wide form</operation>

<format>wide<fsep/>opcode<fsep/>...</format>

<form name="wide" code="COP_WIDE"/>

<description>The <i>wide</i> instruction modifies another
instruction to take longer operands.  The format of the
operands depends upon the <i>opcode</i>.</description>

<notes>The documentation for other instructions includes
information on their wide forms where appropriate.<p/>

There is no direct format for this instruction,
because <i>wide</i> is not required for the direct
encoding.</notes>
</opcode>
<opcode name="prefix" group="Miscellaneous instructions">
<operation>Prefix an alternative instruction</operation>

<format>prefix<fsep/>opcode<fsep/>...</format>

<form name="prefix" code="COP_PREFIX"/>

<description>The <i>prefix</i> instruction is used to
switch the runtime engine into an alternative instruction
set.  The alternative instruction is <i>opcode</i>.
Prefixing is necessary because the VM has more than
256 distinct instructions.</description>

<notes>There is no direct format for this instruction,
because <i>prefix</i> is not required for the direct
encoding.</notes>
</opcode>
<opcode name="unroll_method"
group="Miscellaneous instructions">
<operation>Mark a method for unrolling</operation>

<dformat>{unroll_method}</dformat>

<form name="unroll_method"
code="COP_PREFIX_UNROLL_METHOD"/>

<description>The <i>unroll_method</i> instruction is
used in direct code to trigger native code unrolling.
<p/>

Unrolling converts fragments of the method into
native code for the underlying CPU, to speed up
execution.</description>

<notes>There is no bytecode format for this
instruction, because unrolling is not possible
with the bytecode encoding.<p/>

In a method that can support unrolling, the
<i>nop</i> instruction is used to mark
a label, so that the unroller can process labels
in a single translation pass.  The <i>prefix</i>
instruction is used to mark the end of the method's
code, so that the unroller knows where to stop.
</notes>
</opcode>
<opcode name="call" group="Call management instructions">
<operation>Call a method</operation>

<format>call<fsep/>mptr</format>
<dformat>{call}<fsep/>mptr</dformat>

<form name="call" code="COP_CALL"/>

<description>The <i>call</i> instruction effects a method
call to <i>mptr</i>.  The call proceeds as follows:

<ul>
<li>The method is converted into CVM bytecode.  If this is not
possible, then <code>System.Security.VerificationException</code>
will be thrown.</li>
<li>A new call frame is allocated.</li>
<li>The current method, program counter, frame pointer, and
exception frame height are saved into the call frame.</li>
<li>The program counter is set to the first instruction in
the method <i>mptr</i>.</li>
<li>The current method is set to <i>mptr</i>.</li>
</ul>
</description>

<notes>The <i>mptr</i> value is a 32-bit or 64-bit method
pointer reference.<p/>

The <i>call</i> instruction does not set up a new frame pointer.
The <i>set_num_args</i> instruction is used to set up local variable
frames at the start of the new method's code.

The <i>return*</i> instructions are responsible for popping the
method arguments from the stack at method exit.</notes>

<exceptions>
<exception name="System.Security.VerificationException">Raised if
the method could not be translated into CVM bytecode.</exception>
</exceptions>
</opcode>
<opcode name="call_ctor" group="Call management instructions">
<operation>Call a constructor</operation>

<format>call_ctor<fsep/>mptr</format>
<dformat>{call_ctor}<fsep/>mptr</dformat>

<form name="call_ctor" code="COP_CALL_CTOR"/>

<description>The <i>call_ctor</i> instruction effects a method
call to the constructor identified by <i>mptr</i>.</description>

<notes>Constructors in the CVM system have two entry points: one
which creates a block of memory and then initializes it; and the
other which initializes a pre-allocated block.  The particular
entry point is chosen based on the constructor's usage in the
original CIL bytecode:

<ul>
<li>If the CIL bytecode invoked the constructor method using
<i>newobj</i>, then <i>call_ctor</i> should be used.</li>
<li>If the CIL bytecode invoked a parent class's constructor
method directly using the IL <i>call</i> instruction,
then <i>call</i> should be used.</li>
</ul>

See the description of the <i>call</i> instruction for
a full account of frame handling, argument handling, etc.</notes>
</opcode>
<opcode name="call_native" group="Call management instructions">
<operation>Call a native function that has a return value</operation>

<format>call_native<fsep/>function<fsep/>cif</format>
<dformat>{call_native}<fsep/>function<fsep/>cif</dformat>

<form name="call_native" code="COP_CALL_NATIVE"/>

<before>..., address</before>
<after>...</after>

<description>The <i>call_native</i> instruction effects a native
function call to <i>function</i>, using <i>cif</i> to define the
format of the function arguments and return value.  The return
value is stored at <i>address</i>.  The arguments are assumed
to have already been stored into the "native argument buffer"
using the <i>waddr_native*</i> instructions.</description>

<notes>Both <i>function</i> and <i>cif</i> are native pointers,
which may be either 32 or 64 bits in size, depending upon the
platform.<p/>

Native function calls occur in CIL "InternalCall" and "PInvoke"
methods.  For each such method, the CVM translation process
creates a CVM stub method that transfers the arguments on
the CVM stack to the native argument buffer, makes the native
call, and then puts the function's return value back onto
the CVM stack prior to exiting.</notes>
</opcode>
<opcode name="call_native_void" group="Call management instructions">
<operation>Call a native function with no return value</operation>

<format>call_native_void<fsep/>function<fsep/>cif</format>
<dformat>{call_native_void}<fsep/>function<fsep/>cif</dformat>

<form name="call_native_void" code="COP_CALL_NATIVE_VOID"/>

<description>The <i>call_native_void</i> instruction is identical
to <i>call_native</i>, except that the native function is assumed
not to have a return value.</description>
</opcode>
<opcode name="call_native_raw" group="Call management instructions">
<operation>Call a native function that has a return value,
using a raw call</operation>

<format>call_native_raw<fsep/>function<fsep/>cif</format>
<dformat>{call_native_raw}<fsep/>function<fsep/>cif</dformat>

<form name="call_native_raw" code="COP_CALL_NATIVE_RAW"/>

<before>..., avalue, rvalue</before>
<after>...</after>

<description>The <i>call_native_raw</i> instruction effects a native
function call to <i>function</i>, using <i>cif</i> to define the
format of the function arguments and return value.  The arguments
are stored on the stack beginning at <i>avalue</i>.  The return
value is stored at <i>rvalue</i>.</description>

<notes>This instruction differs from <i>call_native</i> in the manner
in which the call is performed.  This instruction uses a "raw" call,
which is only applicable on some platforms.  The arguments are
passed on the stack, instead of in a separate native argument
buffer.</notes>
</opcode>
<opcode name="call_native_void_raw" group="Call management instructions">
<operation>Call a native function with no return value
using a raw call</operation>

<format>call_native_void_raw<fsep/>function<fsep/>cif</format>
<dformat>{call_native_void_raw}<fsep/>function<fsep/>cif</dformat>

<form name="call_native_void_raw" code="COP_CALL_NATIVE_VOID_RAW"/>

<before>..., avalue</before>
<after>...</after>

<description>The <i>call_native_void_raw</i> instruction is identical
to <i>call_native_raw</i>, except that the native function is assumed
not to have a return value.</description>
</opcode>
<opcode name="call_virtual" group="Call management instructions">
<operation>Call a virtual method</operation>

<format>call_virtual<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>call_virtual<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{call_virtual}<fsep/>N<fsep/>M</dformat>

<form name="call_virtual" code="COP_CALL_VIRTUAL"/>

<description>The <i>call_virtual</i> instruction effects a
virtual method call.  The value <i>N</i> indicates the
position of the <code>this</code> pointer on the stack:
1 indicates the top of stack, 2 indicates the stack word
just below the top-most stack word, etc.  The value <i>M</i>
is the offset into the object's vtable for the method.</description>

<notes>See the description of the <i>call</i> instruction for
a full account of frame handling, argument handling, etc.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
the <code>this</code> pointer is <code>null</code>.</exception>
<exception name="System.Security.VerificationException">Raised if
the method could not be translated into CVM bytecode.</exception>
</exceptions>
</opcode>
<opcode name="call_interface" group="Call management instructions">
<operation>Call an interface method</operation>

<format>call_interface<fsep/>N[1]<fsep/>M[1]<fsep/>cptr</format>
<format>wide<fsep/>call_interface<fsep/>N[4]<fsep/>M[4]<fsep/>cptr</format>
<dformat>{call_interface}<fsep/>N<fsep/>M<fsep/>cptr</dformat>

<form name="call_interface" code="COP_CALL_INTERFACE"/>

<description>The <i>call_interface</i> instruction effects an
interface method call.  The value <i>N</i> indicates the
position of the <code>this</code> pointer on the stack:
1 indicates the top of stack, 2 indicates the stack word
just below the top-most stack word, etc.  The value <i>M</i>
is the offset into the interface's vtable for the method.  The value
<i>cptr</i> indicates the interface class pointer.</description>

<notes>See the description of the <i>call</i> instruction for
a full account of frame handling, argument handling, etc.<p/>

The <i>cptr</i> value is a native pointer that may be either 32 or
64 bits in size, depending upon the platform.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
the <code>this</code> pointer is <code>null</code>.</exception>
<exception name="System.Security.VerificationException">Raised if
the method could not be translated into CVM bytecode.</exception>
</exceptions>
</opcode>
<opcode name="cctor_once" group="Call management instructions">
<operation>Block the current method from being executed
more than once</operation>

<format>cctor_once</format>
<dformat>{cctor_once}</dformat>

<form name="cctor_once" code="COP_CCTOR_ONCE"/>

<description>The <i>cctor_once</i> instruction is typically
the first instruction in a static constructor.  If this is the
first time that the static constructor has been called, then
the method will continue.  Otherwise, the effect will be the
same as for <i>return</i>.</description>

<notes>This instruction permits CVM bytecode to call static
constructors from anywhere in the system, without having to
worry about whether it has already been called.  This instruction
will also prevent recursive static constructor calls from
looping indefinitely.</notes>
</opcode>
<opcode name="return" group="Call management instructions">
<operation>Return from the current method with no return value</operation>

<format>return</format>
<dformat>{return}</dformat>

<form name="return" code="COP_RETURN"/>

<description>Return control to the method that called the current
method, as follows:

<ul>
<li>Set the top of stack pointer to the frame pointer.</li>
<li>Pop the top-most call frame from the call frame stack.</li>
<li>Retrieve the method pointer, progrm counter, exception frame
height, and the frame pointer from the call frame.</li>
</ul>
</description>

<notes>The <i>set_num_args</i> instruction has previously set the
frame pointer to the address of the first argument.  When <i>return</i>
is executed, the first step above will pop all of the arguments.</notes>
</opcode>
<opcode name="return_1" group="Call management instructions">
<operation>Return from the current method with a single stack
word as a return value</operation>

<format>return_1</format>
<dformat>{return_1}</dformat>

<form name="return_1" code="COP_RETURN_1"/>

<description>Return control to the method that called the current
method, as follows:

<ul>
<li>Copy the top-most word on the stack to the position
indicated by the frame pointer, and then set the top
of stack pointer to point just after the copy.</li>
<li>Pop the top-most call frame from the call frame stack.</li>
<li>Retrieve the method pointer, progrm counter, exception frame
height, and the frame pointer from the call frame.</li>
</ul>
</description>

<notes>The <i>set_num_args</i> instruction has previously set the
frame pointer to the address of the first argument.  When <i>return_1</i>
is executed, the first step above will pop all of the arguments,
with the single-word return value left in their place.</notes>
</opcode>
<opcode name="return_2" group="Call management instructions">
<operation>Return from the current method with two stack
words as the return value</operation>

<format>return_2</format>
<dformat>{return_2}</dformat>

<form name="return_2" code="COP_RETURN_2"/>

<description>Return control to the method that called the current
method, as follows:

<ul>
<li>Copy the two top-most words on the stack to the position
indicated by the frame pointer, and then set the top
of stack pointer to point just after the two copied words.</li>
<li>Pop the top-most call frame from the call frame stack.</li>
<li>Retrieve the method pointer, progrm counter, exception frame
height, and the frame pointer from the call frame.</li>
</ul>
</description>

<notes>The <i>set_num_args</i> instruction has previously set the
frame pointer to the address of the first argument.  When <i>return_2</i>
is executed, the first step above will pop all of the arguments,
with the double-word return value left in their place.</notes>
</opcode>
<opcode name="return_n" group="Call management instructions">
<operation>Return from the current method with <i>n</i> stack
words as the return value</operation>

<format>return_n<fsep/>N[4]</format>
<dformat>{return_n}<fsep/>N</dformat>

<form name="return_n" code="COP_RETURN_N"/>

<description>Return control to the method that called the current
method, as follows:

<ul>
<li>Copy the <i>n</i> top-most words on the stack to the position
indicated by the frame pointer, and then set the top of
stack pointer to point just after the <i>n</i> copied words.</li>
<li>Pop the top-most call frame from the call frame stack.</li>
<li>Retrieve the method pointer, progrm counter, exception frame
height, and the frame pointer from the call frame.</li>
</ul>
</description>

<notes>The <i>set_num_args</i> instruction has previously set the
frame pointer to the address of the first argument.  When <i>return_n</i>
is executed, the first step above will pop all of the arguments,
with the <i>n</i>-word return value left in their place.</notes>
</opcode>
<opcode name="push_thread" group="Call management instructions">
<operation>Push the thread identifier onto the native
argument stack</operation>

<format>push_thread</format>
<dformat>{push_thread}</dformat>

<form name="push_thread" code="COP_PUSH_THREAD"/>

<description>Pushes an identifier for the current thread onto
the native argument stack.  This is only used for "InternalCall"
methods.  "PInvoke" methods should use <i>waddr_native_m1</i> instead.
</description>
</opcode>
<opcode name="push_thread_raw" group="Call management instructions">
<operation>Push the thread identifier onto the native
argument stack as a raw value</operation>

<format>push_thread_raw</format>
<dformat>{push_thread_raw}</dformat>

<form name="push_thread_raw" code="COP_PUSH_THREAD_RAW"/>

<description>Pushes an identifier for the current thread onto
the native argument stack.  This is only used for "InternalCall"
methods.  This instruction differs from <i>push_thread</i> in
that it is intended for use with <i>call_native_raw</i> instead
of <i>call_native</i>.</description>
</opcode>
<opcode name="pushdown" group="Call management instructions">
<operation>Push the <code>ptr</code> value at the top of
stack down and duplicate it twice</operation>

<format>pushdown<fsep/>N[4]</format>
<dformat>{pushdown}<fsep/>N</dformat>

<form name="pushdown" code="COP_PUSHDOWN"/>

<before>..., val1, ..., valN, value</before>
<after>..., value, value, val1, ..., valN</after>

<description>The <i>value</i> at the top of the stack is popped,
pushed down <i>N</i> stack words, and duplicated twice.</description>

<notes>This instruction is used in combination with <i>new</i>
to construct a block of memory for a new object.  The block
is allocated, and then pushed down.  The lowest duplicated
<i>value</i> becomes the return value for the constructor method.
The other duplicated <i>value</i> becomes the <code>this</code>
argument for the constructor method.</notes>
</opcode>
<opcode name="waddr_native_&lt;n&gt;" group="Call management instructions">
<operation>Set position <i>n</i> of the native argument buffer
to the address of a local variable</operation>

<format>waddr_native_&lt;n&gt;<fsep/>V[1]</format>
<format>wide<fsep/>waddr_native_&lt;n&gt;<fsep/>V[4]</format>
<dformat>{waddr_native_&lt;n&gt;}<fsep/>V</dformat>

<form name="waddr_native_m1" code="COP_WADDR_NATIVE_M1"/>
<form name="waddr_native_0" code="COP_WADDR_NATIVE_0"/>
<form name="waddr_native_1" code="COP_WADDR_NATIVE_1"/>
<form name="waddr_native_2" code="COP_WADDR_NATIVE_2"/>
<form name="waddr_native_3" code="COP_WADDR_NATIVE_3"/>
<form name="waddr_native_4" code="COP_WADDR_NATIVE_4"/>
<form name="waddr_native_5" code="COP_WADDR_NATIVE_5"/>
<form name="waddr_native_6" code="COP_WADDR_NATIVE_6"/>
<form name="waddr_native_7" code="COP_WADDR_NATIVE_7"/>

<description>Set position <i>n</i> of the native argument buffer
to the address of local variable <i>V</i>.  For an "InternalCall"
method, 0 is the first argument.  For a "PInvoke" method,
-1 (<i>m1</i>) is the first argument.</description>
</opcode>
<opcode name="tail_call" group="Call management instructions">
<operation>Call a method using tail call semantics</operation>

<format>prefix<fsep/>tail_call<fsep/>mptr</format>
<dformat>{tail_call}<fsep/>mptr</dformat>

<form name="tail_call" code="COP_PREFIX_TAIL_CALL"/>

<description>This instruction is identical to <i>call</i>, except
that it performs a tail-optimized call to the method identified
by <i>mptr</i>.</description>
</opcode>
<opcode name="tail_calli" group="Call management instructions">
<operation>Call a method using indirect tail call semantics</operation>

<format>prefix<fsep/>tail_calli</format>
<dformat>{tail_calli}</dformat>

<form name="tail_calli" code="COP_PREFIX_TAIL_CALLI"/>

<description>This instruction is identical to <i>calli</i>, except
that it performs a tail-optimized call.</description>
</opcode>
<opcode name="tail_callvirt" group="Call management instructions">
<operation>Call a virtual method using tail call semantics</operation>

<format>prefix<fsep/>tail_callvirt<fsep/>N[1]<fsep/>M[1]</format>
<dformat>{tail_callvirt}<fsep/>N<fsep/>M</dformat>

<form name="tail_callvirt" code="COP_PREFIX_TAIL_CALLVIRT"/>

<description>The <i>tail_callvirt</i> instruction is identical
to <i>call_virtual</i>, except that it uses tail call semantics.
</description>
</opcode>
<opcode name="tail_callintf" group="Call management instructions">
<operation>Call an interface method using tail call semantics</operation>

<format>prefix<fsep/>tail_callintf<fsep/>N[1]<fsep/>M[1]<fsep/>cptr</format>
<dformat>{tail_callintf}<fsep/>N<fsep/>M<fsep/>cptr</dformat>

<form name="tail_callintf" code="COP_PREFIX_TAIL_CALLINTF"/>

<description>The <i>tail_callintf</i> instruction is identical
to <i>call_interface</i>, except that it uses tail call semantics.
</description>
</opcode>
<opcode name="ldftn" group="Call management instructions">
<operation>Load the address of a function method onto the stack</operation>

<format>prefix<fsep/>ldftn<fsep/>method</format>
<dformat>{ltftn}<fsep/>method</dformat>

<form name="ldftn" code="COP_PREFIX_LDFTN"/>

<before>...</before>
<after>..., method</after>

<description>Push <i>method</i> onto the stack as a <code>ptr</code>
value.</description>

<notes>The <i>method</i> value may be either 32 or 64 bits in size,
depending upon the platform.</notes>
</opcode>
<opcode name="ldvirtftn" group="Call management instructions">
<operation>Load the address of a virtual function method
onto the stack</operation>

<format>prefix<fsep/>ldvirtftn<fsep/>index[4]</format>
<dformat>{ltvirtftn}<fsep/>index</dformat>

<form name="ldvirtftn" code="COP_PREFIX_LDVIRTFTN"/>

<before>..., object</before>
<after>..., address</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>
and locate the virtual method at <i>index</i> within the object's
vtable.  The address of this method is pushed onto the stack
as type <code>ptr</code>.</description>
</opcode>
<opcode name="ldinterfftn" group="Call management instructions">
<operation>Load the address of an interface function method
onto the stack</operation>

<format>prefix<fsep/>ldinterfftn<fsep/>index[4]<fsep/>class</format>
<dformat>{ltinterfftn}<fsep/>index<fsep/>class</dformat>

<form name="ldinterfftn" code="COP_PREFIX_LDINTERFFTN"/>

<before>..., object</before>
<after>..., address</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>
and locate the virtual method at <i>index</i> within the object's
interface vtable for the interface <i>class</i>.  The address of
this method is pushed onto the stack as type
<code>ptr</code>.</description>

<notes>The <i>class</i> value may be either 32 or 64 bits in size,
depending upon the platform.</notes>
</opcode>
<opcode name="pack_varargs" group="Call management instructions">
<operation>Pack a set of arguments for a vararg method call</operation>

<format>prefix<fsep/>pack_varargs<fsep/>first[4]
<fsep/>num[4]<fsep/>signature</format>
<dformat>{pack_varargs}<fsep/>first<fsep/>num<fsep/>signature</dformat>

<form name="pack_varargs" code="COP_PREFIX_PACK_VARARGS"/>

<before>..., arg1, ..., argN</before>
<after>..., array</after>

<description>Pop <i>N</i> words from the stack and pack them
into an array of type <code>System.Object</code>.  The <i>first</i>
value is the index of the first parameter in <i>signature</i>
that corresponds to a word on the stack.  The <i>num</i> value is
the number of logical arguments to be packed.  The final
<i>array</i> is pushed onto the stack as type <code>ptr</code>.
</description>

<notes>The <i>signature</i> value may be either 32 or 64 bits in size,
depending upon the platform, and will usually include a sentinel
marker at position <i>first - 1</i>.  The <i>signature</i> may not
have a sentinel marker if <i>num</i> is zero.<p/>

This instruction is used to pack the arguments for a call to a
<code>vararg</code> method.  The method itself will receive a
single argument containing a pointer to the array.</notes>
</opcode>
<opcode name="profile_count" group="Profiling Instructions">
<operation>Count the number of times the current method is
invoked</operation>

<format>profile_count</format>
<dformat>{profile_count}</dformat>

<form name="profile_count" code="COP_PREFIX_PROFILE_COUNT"/>

<description>This instruction adds 1 to the profiling count for
the current method.  It is normally inserted at the beginning
of a method's code by the CVM coder when the engine is running
in the profiling mode.</description>
</opcode>
<opcode name="waddr_native_n" group="Call management instructions">
<operation>Set position <i>n</i> of the native argument buffer
to the address of a local variable</operation>

<format>prefix<fsep/>waddr_native_n<fsep/>N[4]<fsep/>V[4]</format>
<dformat>{waddr_native_n}<fsep/>N<fsep/>V</dformat>

<form name="waddr_native_n" code="COP_PREFIX_WADDR_NATIVE_N"/>

<description>Set position <i>N</i> of the native argument buffer
to the address of local variable <i>V</i>.  For an "InternalCall"
method, 0 is the first argument.  For a "PInvoke" method,
-1 (<i>m1</i>) is the first argument.</description>
</opcode>
<opcode name="trace_in" group="Profiling Instructions">
<operation>Print the name of the called method . This is injected
at the top of every method in --trace mode</operation>

<format>trace_in<fsep/>reason</format>
<dformat>{trace_in}<fsep/>reason</dformat>

<form name="trace_in" code="COP_PREFIX_TRACE_IN"/>

<description>This instruction prints out the called method .
It is normally inserted immediately before a method call when
the engine is running in --trace mode. The reason parameter
is provided for future additions , and is ignored in the current
implementation.
</description>
</opcode>
<opcode name="trace_out" group="Profiling Instructions">
<operation>Print the name of the callee method while returning to it.
This is injected for every return in --trace mode</operation>

<format>trace_out<fsep/>reason</format>
<dformat>{trace_out}<fsep/>reason</dformat>

<form name="trace_out" code="COP_PREFIX_TRACE_OUT"/>

<description>This instruction prints out the callee method
on returning from the current method.  It is normally inserted
immediately before a return from a method when the engine is
running in --trace mode.
</description>
</opcode>
<opcode name="icmp" group="Comparison operators">
<operation>Compare <code>int32</code></operation>

<format>prefix<fsep/>icmp</format>
<dformat>{icmp}</dformat>

<form name="icmp" code="COP_PREFIX_ICMP"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int32</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="icmp_un" group="Comparison operators">
<operation>Compare <code>uint32</code></operation>

<format>prefix<fsep/>icmp_un</format>
<dformat>{icmp_un}</dformat>

<form name="icmp_un" code="COP_PREFIX_ICMP_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint32</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="lcmp" group="Comparison operators">
<operation>Compare <code>int64</code></operation>

<format>prefix<fsep/>lcmp</format>
<dformat>{lcmp}</dformat>

<form name="lcmp" code="COP_PREFIX_LCMP"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>int64</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="lcmp_un" group="Comparison operators">
<operation>Compare <code>uint64</code></operation>

<format>prefix<fsep/>lcmp_un</format>
<dformat>{lcmp_un}</dformat>

<form name="lcmp_un" code="COP_PREFIX_LCMP_UN"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>uint64</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="fcmpl" group="Comparison operators">
<operation>Compare <code>native float</code> with lower result</operation>

<format>prefix<fsep/>fcmpl</format>
<dformat>{fcmpl}</dformat>

<form name="fcmpl" code="COP_PREFIX_FCMPL"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If either <i>value1</i> or <i>value2</i> is NaN, then
<i>result</i> is -1.</li>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="fcmpg" group="Comparison operators">
<operation>Compare <code>native float</code> with
greater result</operation>

<format>prefix<fsep/>fcmpg</format>
<dformat>{fcmpg}</dformat>

<form name="fcmpg" code="COP_PREFIX_FCMPG"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>native float</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If either <i>value1</i> or <i>value2</i> is NaN, then
<i>result</i> is 1.</li>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="pcmp" group="Comparison operators">
<operation>Compare <code>ptr</code></operation>

<format>prefix<fsep/>pcmp</format>
<dformat>{pcmp}</dformat>

<form name="pcmp" code="COP_PREFIX_PCMP"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i>
are popped from the stack as type <code>ptr</code>.  The
<code>int32</code> <i>result</i> is determined as follows:

<ul>
<li>If <i>value1 &lt; value2</i>, then <i>result</i> is -1.</li>
<li>If <i>value1 &gt; value2</i>, then <i>result</i> is 1.</li>
<li>Otherwise, <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="seteq" group="Comparison operators">
<operation>Set if equal to zero</operation>

<format>prefix<fsep/>seteq</format>
<dformat>{seteq}</dformat>

<form name="seteq" code="COP_PREFIX_SETEQ"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 == 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 != 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="setne" group="Comparison operators">
<operation>Set if not equal to zero</operation>

<format>prefix<fsep/>setne</format>
<dformat>{setne}</dformat>

<form name="setne" code="COP_PREFIX_SETNE"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 != 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 == 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="setlt" group="Comparison operators">
<operation>Set if less than zero</operation>

<format>prefix<fsep/>setlt</format>
<dformat>{setlt}</dformat>

<form name="setlt" code="COP_PREFIX_SETLT"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 &lt; 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 &gt;= 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="setle" group="Comparison operators">
<operation>Set if less than or equal to zero</operation>

<format>prefix<fsep/>setle</format>
<dformat>{setle}</dformat>

<form name="setle" code="COP_PREFIX_SETLE"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 &lt;= 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 &gt; 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="setgt" group="Comparison operators">
<operation>Set if greater than zero</operation>

<format>prefix<fsep/>setgt</format>
<dformat>{setgt}</dformat>

<form name="setgt" code="COP_PREFIX_SETGT"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 &gt; 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 &lt;= 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="setge" group="Comparison operators">
<operation>Set if greater than or equal to zero</operation>

<format>prefix<fsep/>setge</format>
<dformat>{setge}</dformat>

<form name="setge" code="COP_PREFIX_SETGE"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is determined as follows:

<ul>
<li>If <i>value1 &gt;= 0</i>, then <i>result</i> is 1.</li>
<li>If <i>value1 &lt; 0</i>, then <i>result</i> is 0.</li>
</ul>

The <i>result</i> is then pushed onto the stack.</description>
</opcode>
<opcode name="ldnull" group="Constant loading">
<operation>Load <code>null</code> onto the stack</operation>

<format>ldnull</format>
<dformat>{ldnull}</dformat>

<form name="ldnull" code="COP_LDNULL"/>

<before>...</before>
<after>..., value</after>

<description>The <i>value</i> <code>null</code> is pushed onto
the stack as type <code>ptr</code>.</description>

<notes>This instruction must not be confused with <i>ldc_i4_0</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="ldc_i4_&lt;n&gt;" group="Constant loading">
<operation>Load <i>n</i> onto the stack</operation>

<format>ldc_i4_&lt;n&gt;</format>
<dformat>{ldc_i4_&lt;n&gt;}</dformat>

<form name="ldc_i4_m1" code="COP_LDC_I4_M1"/>
<form name="ldc_i4_0" code="COP_LDC_I4_0"/>
<form name="ldc_i4_1" code="COP_LDC_I4_1"/>
<form name="ldc_i4_2" code="COP_LDC_I4_2"/>
<form name="ldc_i4_3" code="COP_LDC_I4_3"/>
<form name="ldc_i4_4" code="COP_LDC_I4_4"/>
<form name="ldc_i4_5" code="COP_LDC_I4_5"/>
<form name="ldc_i4_6" code="COP_LDC_I4_6"/>
<form name="ldc_i4_7" code="COP_LDC_I4_7"/>
<form name="ldc_i4_8" code="COP_LDC_I4_8"/>

<before>...</before>
<after>..., value</after>

<description>The <i>value</i> <i>n</i> is pushed onto
the stack as type <code>int32</code>.</description>

<notes>These instructions can also be used to load constants
of type <code>uint32</code> onto the stack.</notes>
</opcode>
<opcode name="ldc_i4_s" group="Constant loading">
<operation>Load small <code>int32</code> constant
onto the stack</operation>

<format>ldc_i4_s<fsep/>n</format>
<dformat>{ldc_i4_s}<fsep/>n</dformat>

<form name="ldc_i4_s" code="COP_LDC_I4_S"/>

<before>...</before>
<after>..., value</after>

<description>The signed 8-bit <i>value</i> <i>n</i>
is pushed onto the stack as type <code>int32</code>.</description>

<notes>This instruction can also be used to load constants
of type <code>uint32</code> onto the stack.</notes>
</opcode>
<opcode name="ldc_i4" group="Constant loading">
<operation>Load <code>int32</code> constant onto the stack</operation>

<format>ldc_i4<fsep/>n[4]</format>
<dformat>{ldc_i4}<fsep/>n</dformat>

<form name="ldc_i4" code="COP_LDC_I4"/>

<before>...</before>
<after>..., value</after>

<description>The 32-bit <i>value</i> <i>n</i>
is pushed onto the stack as type <code>int32</code>.</description>

<notes>This instruction can also be used to load constants
of type <code>uint32</code> onto the stack.</notes>
</opcode>
<opcode name="ldc_i8" group="Constant loading">
<operation>Load <code>int64</code> constant onto the stack</operation>

<format>ldc_i8<fsep/>n[8]</format>
<dformat>{ldc_i8}<fsep/>n[8]</dformat>

<form name="ldc_i8" code="COP_LDC_I8"/>

<before>...</before>
<after>..., value</after>

<description>The 64-bit <i>value</i> <i>n</i>
is pushed onto the stack as type <code>int64</code>.</description>

<notes>This instruction can also be used to load constants
of type <code>uint64</code> onto the stack.</notes>
</opcode>
<opcode name="ldc_r4" group="Constant loading">
<operation>Load 32-bit floating point constant onto the stack</operation>

<format>ldc_r4<fsep/>n[4]</format>
<dformat>{ldc_r4}<fsep/>n[4]</dformat>

<form name="ldc_r4" code="COP_LDC_R4"/>

<before>...</before>
<after>..., value</after>

<description>The 32-bit floating point value <i>n</i> is fetched,
converted to <code>native float</code>, and then pushed onto the
stack as <i>value</i>.</description>
</opcode>
<opcode name="ldc_r8" group="Constant loading">
<operation>Load 64-bit floating point constant onto the stack</operation>

<format>ldc_r8<fsep/>n[8]</format>

<form name="ldc_r8" code="COP_LDC_R8"/>
<dformat>{ldc_r8}<fsep/>n[8]</dformat>

<before>...</before>
<after>..., value</after>

<description>The 64-bit floating point value <i>n</i> is fetched,
converted to <code>native float</code>, and then pushed onto the
stack as <i>value</i>.</description>
</opcode>
<opcode name="i2b" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int8</code></operation>

<format>i2b</format>
<dformat>{i2b}</dformat>

<form name="i2b" code="COP_I2B"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 8 bits and then
sign-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="i2ub" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint8</code></operation>

<format>i2ub</format>
<dformat>{i2ub}</dformat>

<form name="i2ub" code="COP_I2UB"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 8 bits and then
zero-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="i2s" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int16</code></operation>

<format>i2s</format>
<dformat>{i2s}</dformat>

<form name="i2s" code="COP_I2S"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 16 bits and then
sign-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="i2us" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint16</code></operation>

<format>i2us</format>
<dformat>{i2us}</dformat>

<form name="i2us" code="COP_I2US"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 16 bits and then
zero-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.</description>
</opcode>
<opcode name="i2l" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int64</code></operation>

<format>i2l</format>
<dformat>{i2l}</dformat>

<form name="i2l" code="COP_I2L"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int64</code> <i>result</i>
is formed by sign-extending <i>value</i> to 64 bits.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="iu2l" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>int64</code></operation>

<format>iu2l</format>
<dformat>{iu2l}</dformat>

<form name="iu2l" code="COP_IU2L"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  The <code>int64</code> <i>result</i>
is formed by zero-extending <i>value</i> to 64 bits.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="i2f" group="Conversion operators">
<operation>Convert <code>int32</code> to
<code>native float</code></operation>

<format>i2f</format>
<dformat>{i2f}</dformat>

<form name="i2f" code="COP_I2F"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>, and converted into a <code>native float</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="iu2f" group="Conversion operators">
<operation>Convert <code>uint32</code> to
<code>native float</code></operation>

<format>iu2f</format>
<dformat>{iu2f}</dformat>

<form name="iu2f" code="COP_IU2F"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>, and converted into a <code>native float</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="l2i" group="Conversion operators">
<operation>Convert <code>int64</code> to <code>int32</code></operation>

<format>l2i</format>
<dformat>{l2i}</dformat>

<form name="l2i" code="COP_L2I"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 32 bits.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="l2f" group="Conversion operators">
<operation>Convert <code>int64</code> to
<code>native float</code></operation>

<format>l2f</format>
<dformat>{l2f}</dformat>

<form name="l2f" code="COP_L2F"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>, and converted into a <code>native float</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>

<notes>The precision of the <code>native float</code> type is
platform-dependent.  On some platforms, it may be sufficient to
represent all <code>int64</code> values, and on other platforms it
may round large values.  Programs should not rely upon precise
conversions from <code>int64</code> to <code>native float</code>.</notes>
</opcode>
<opcode name="lu2f" group="Conversion operators">
<operation>Convert <code>uint64</code> to
<code>native float</code></operation>

<format>lu2f</format>
<dformat>{lu2f}</dformat>

<form name="lu2f" code="COP_LU2F"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint64</code>, and converted into a <code>native float</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>

<notes>The precision of the <code>native float</code> type is
platform-dependent.  On some platforms, it may be sufficient to
represent all <code>uint64</code> values, and on other platforms it
may round large values.  Programs should not rely upon precise
conversions from <code>uint64</code> to <code>native float</code>.</notes>
</opcode>
<opcode name="f2i" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>int32</code></operation>

<format>f2i</format>
<dformat>{f2i}</dformat>

<form name="f2i" code="COP_F2I"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, and converted into an <code>int32</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="f2iu" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>uint32</code></operation>

<format>f2iu</format>
<dformat>{f2iu}</dformat>

<form name="f2iu" code="COP_F2IU"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, and converted into an <code>uint32</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="f2l" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>int64</code></operation>

<format>f2l</format>
<dformat>{f2l}</dformat>

<form name="f2l" code="COP_F2L"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, and converted into an <code>int64</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="f2lu" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>uint64</code></operation>

<format>f2lu</format>
<dformat>{f2lu}</dformat>

<form name="f2lu" code="COP_F2LU"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, and converted into an <code>uint64</code>
<i>result</i>.  The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="f2f" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>float32</code></operation>

<format>f2f</format>
<dformat>{f2f}</dformat>

<form name="f2f" code="COP_F2F"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, truncated to <code>float32</code>,
and then converted into a <code>native float</code> <i>result</i>.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="f2d" group="Conversion operators">
<operation>Convert <code>native float</code> to
<code>float64</code></operation>

<format>f2d</format>
<dformat>{f2d}</dformat>

<form name="f2d" code="COP_F2D"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>, truncated to <code>float64</code>,
and then converted into a <code>native float</code> <i>result</i>.
The <i>result</i> is pushed onto the stack.</description>
</opcode>
<opcode name="i2p_lower" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>ptr</code>
at some point lower down on the stack</operation>

<format>i2p_lower<fsep/>N[1]</format>
<format>wide<fsep/>i2p_lower<fsep/>N[4]</format>
<dformat>{i2p_lower}<fsep/>N</dformat>

<form name="f2d" code="COP_F2D"/>

<before>..., value, val1, ..., valN</before>
<after>..., result, val1, ..., valN</after>

<description>The <i>value</i> at stack word <i>N</i> positions
down from the top of the stack is converted from <code>uint32</code>
into a <code>ptr</code> <i>result</i>.  <i>N == 0</i> indicates
that <i>value</i> is on the top of the stack.</description>

<notes>This is typically used to convert CIL "I4" values into "I" values
for use in unmanaged pointer operations.</notes>
</opcode>
<opcode name="i2b_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int8</code>
with overflow detection</operation>

<format>prefix<fsep/>i2b_ovf</format>
<dformat>{i2b_ovf}</dformat>

<form name="i2b_ovf" code="COP_PREFIX_I2B_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 8 bits and then
sign-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.  If <i>result</i> does not have the same numeric
value as <i>value</i>, then <code>System.OverflowException</code>
is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int8</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2ub_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint8</code>
with overflow detection</operation>

<format>prefix<fsep/>i2ub_ovf</format>
<dformat>{i2ub_ovf}</dformat>

<form name="i2ub_ovf" code="COP_PREFIX_I2UB_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 8 bits and then
zero-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.  If <i>result</i> does not have the same numeric
value as <i>value</i>, then <code>System.OverflowException</code>
is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint8</code>.</exception>
</exceptions>
</opcode>
<opcode name="iu2b_ovf" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>int8</code>
with overflow detection</operation>

<format>prefix<fsep/>iu2b_ovf</format>
<dformat>{iu2b_ovf}</dformat>

<form name="iu2b_ovf" code="COP_PREFIX_IU2B_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If <i>value</i> is greater than 127,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int8</code>.</exception>
</exceptions>
</opcode>
<opcode name="iu2ub_ovf" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>uint8</code>
with overflow detection</operation>

<format>prefix<fsep/>iu2ub_ovf</format>
<dformat>{iu2ub_ovf}</dformat>

<form name="iu2ub_ovf" code="COP_PREFIX_IU2UB_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If <i>value</i> is greater than 255,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint8</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2s_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int16</code>
with overflow detection</operation>

<format>prefix<fsep/>i2s_ovf</format>
<dformat>{i2s_ovf}</dformat>

<form name="i2s_ovf" code="COP_PREFIX_I2S_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 16 bits and then
sign-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.  If <i>result</i> does not have the same numeric
value as <i>value</i>, then <code>System.OverflowException</code>
is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int16</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2us_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint16</code>
with overflow detection</operation>

<format>prefix<fsep/>i2us_ovf</format>
<dformat>{i2us_ovf}</dformat>

<form name="i2us_ovf" code="COP_PREFIX_I2US_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 16 bits and then
zero-extending it to 32 bits.  The <i>result</i> is pushed
onto the stack.  If <i>result</i> does not have the same numeric
value as <i>value</i>, then <code>System.OverflowException</code>
is thrown.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint16</code>.</exception>
</exceptions>
</opcode>
<opcode name="iu2s_ovf" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>int16</code>
with overflow detection</operation>

<format>prefix<fsep/>iu2s_ovf</format>
<dformat>{iu2s_ovf}</dformat>

<form name="iu2s_ovf" code="COP_PREFIX_IU2S_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If <i>value</i> is greater than 32767,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int16</code>.</exception>
</exceptions>
</opcode>
<opcode name="iu2us_ovf" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>uint16</code>
with overflow detection</operation>

<format>prefix<fsep/>iu2us_ovf</format>
<dformat>{iu2us_ovf}</dformat>

<form name="iu2us_ovf" code="COP_PREFIX_IU2US_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If <i>value</i> is greater than 65535,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint16</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2iu_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint32</code>
with overflow detection</operation>

<format>prefix<fsep/>i2iu_ovf</format>
<dformat>{i2iu_ovf}</dformat>

<form name="i2iu_ovf" code="COP_PREFIX_I2IU_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  If <i>value</i> is less than zero,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="iu2i_ovf" group="Conversion operators">
<operation>Convert <code>uint32</code> to <code>int32</code>
with overflow detection</operation>

<format>prefix<fsep/>iu2i_ovf</format>
<dformat>{iu2i_ovf}</dformat>

<form name="iu2i_ovf" code="COP_PREFIX_IU2I_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint32</code>.  If <i>value</i> is greater than 2147483647,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2ul_ovf" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>uint64</code>
with overflow detection</operation>

<format>prefix<fsep/>i2ul_ovf</format>
<dformat>{i2ul_ovf}</dformat>

<form name="i2ul_ovf" code="COP_PREFIX_I2UL_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  If <i>value</i> is negative,
then <code>System.OverflowException</code> is thrown.  Otherwise
<i>result</i> is <i>value</i>, zero-extended to 64 bits.
The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="l2i_ovf" group="Conversion operators">
<operation>Convert <code>int64</code> to <code>int32</code>
with overflow detection</operation>

<format>prefix<fsep/>l2i_ovf</format>
<dformat>{l2i_ovf}</dformat>

<form name="l2i_ovf" code="COP_PREFIX_L2I_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>.  If <i>value</i> is less than -2147483648,
or greater than 2147483647, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, truncated
to 32 bits.  The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="l2ui_ovf" group="Conversion operators">
<operation>Convert <code>int64</code> to <code>uint32</code>
with overflow detection</operation>

<format>prefix<fsep/>l2ui_ovf</format>
<dformat>{l2ui_ovf}</dformat>

<form name="l2ui_ovf" code="COP_PREFIX_L2UI_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>.  If <i>value</i> is less than zero or
greater than 4294967295, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, truncated
to 32 bits.  The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="lu2i_ovf" group="Conversion operators">
<operation>Convert <code>uint64</code> to <code>int32</code>
with overflow detection</operation>

<format>prefix<fsep/>lu2i_ovf</format>
<dformat>{lu2i_ovf}</dformat>

<form name="lu2i_ovf" code="COP_PREFIX_LU2I_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint64</code>.  If <i>value</i> is greater than
2147483647, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, truncated
to 32 bits.  The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="lu2iu_ovf" group="Conversion operators">
<operation>Convert <code>uint64</code> to <code>uint32</code>
with overflow detection</operation>

<format>prefix<fsep/>lu2iu_ovf</format>
<dformat>{lu2iu_ovf}</dformat>

<form name="lu2iu_ovf" code="COP_PREFIX_LU2IU_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint64</code>.  If <i>value</i> is greater than
4294967295, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, truncated
to 32 bits.  The <i>result</i> is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="l2ul_ovf" group="Conversion operators">
<operation>Convert <code>int64</code> to <code>uint64</code>
with overflow detection</operation>

<format>prefix<fsep/>l2ul_ovf</format>
<dformat>{l2ul_ovf}</dformat>

<form name="l2ul_ovf" code="COP_PREFIX_L2UL_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int64</code>.  If <i>value</i> is less than zero,
then <code>System.OverflowException</code> is thrown.
Otherwise <i>result</i> is <i>value</i>.  The <i>result</i>
is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="lu2l_ovf" group="Conversion operators">
<operation>Convert <code>uint64</code> to <code>int64</code>
with overflow detection</operation>

<format>prefix<fsep/>lu2l_ovf</format>
<dformat>{lu2l_ovf}</dformat>

<form name="lu2l_ovf" code="COP_PREFIX_LU2L_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>uint64</code>.  If <i>value</i> is greater than
9223372036854775807, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>.  The <i>result</i>
is pushed onto the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int64</code>.</exception>
</exceptions>
</opcode>
<opcode name="f2i_ovf" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>int32</code>
with overflow detection</operation>

<format>prefix<fsep/>f2i_ovf</format>
<dformat>{f2i_ovf}</dformat>

<form name="f2i_ovf" code="COP_PREFIX_F2I_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  If <i>value</i> is not representable
as a 32-bit integer, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, converted to
<code>int32</code>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int32</code>.</exception>
</exceptions>
</opcode>
<opcode name="f2iu_ovf" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>uint32</code>
with overflow detection</operation>

<format>prefix<fsep/>f2iu_ovf</format>
<dformat>{f2iu_ovf}</dformat>

<form name="f2iu_ovf" code="COP_PREFIX_F2IU_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  If <i>value</i> is not representable
as an unsigned 32-bit integer, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, converted to
<code>uint32</code>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint32</code>.</exception>
</exceptions>
</opcode>
<opcode name="f2l_ovf" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>int64</code>
with overflow detection</operation>

<format>prefix<fsep/>f2l_ovf</format>
<dformat>{f2l_ovf}</dformat>

<form name="f2l_ovf" code="COP_PREFIX_F2L_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  If <i>value</i> is not representable
as a 64-bit integer, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, converted to
<code>int64</code>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>int64</code>.</exception>
</exceptions>
</opcode>
<opcode name="f2lu_ovf" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>uint64</code>
with overflow detection</operation>

<format>prefix<fsep/>f2lu_ovf</format>
<dformat>{f2lu_ovf}</dformat>

<form name="f2lu_ovf" code="COP_PREFIX_F2LU_OVF"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  If <i>value</i> is not representable
as an unsigned 64-bit integer, then <code>System.OverflowException</code>
is thrown.  Otherwise <i>result</i> is <i>value</i>, converted to
<code>uint64</code>.  The <i>result</i> is pushed onto
the stack.</description>

<exceptions>
<exception name="System.OverflowException">Raised if <i>value</i>
is out of range for <code>uint64</code>.</exception>
</exceptions>
</opcode>
<opcode name="i2b_aligned" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int8</code>, aligned
on a stack word boundary</operation>

<format>i2b_aligned</format>
<dformat>{i2b_aligned}</dformat>

<form name="i2b_aligned" code="COP_PREFIX_I2B_ALIGNED"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 8 bits.  The <i>result</i>
is stored in the top-most stack position so that it is aligned
with the beginning of the stack word.</description>

<notes>This instruction is used to align a value prior to boxing
it with the <i>box</i> instruction.</notes>
</opcode>
<opcode name="i2s_aligned" group="Conversion operators">
<operation>Convert <code>int32</code> to <code>int16</code>, aligned
on a stack word boundary</operation>

<format>prefix<fsep/>i2s_aligned</format>
<dformat>{i2s_aligned}</dformat>

<form name="i2s_aligned" code="COP_PREFIX_I2S_ALIGNED"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>int32</code>.  The <code>int32</code> <i>result</i>
is formed by truncating <i>value</i> to 16 bits.  The <i>result</i>
is stored in the top-most stack position so that it is aligned
with the beginning of the stack word.</description>

<notes>This instruction is used to align a value prior to boxing
it with the <i>box</i> instruction.</notes>
</opcode>
<opcode name="f2f_aligned" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>float32</code>,
aligned on a stack word boundary</operation>

<format>prefix<fsep/>f2f_aligned</format>
<dformat>{f2f_aligned}</dformat>

<form name="f2f_aligned" code="COP_PREFIX_F2F_ALIGNED"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  The <code>float32</code> <i>result</i>
is formed by truncating <i>value</i> to 32 bits.  The <i>result</i>
is stored in the top-most stack position so that it is aligned
with the beginning of the stack word.</description>

<notes>This instruction is used to align a value prior to boxing
it with the <i>box</i> instruction.<p/>

The <code>float32</code> type may occupy less stack words than
the original <code>native float</code> value.  Excess stack words
are popped from the stack.</notes>
</opcode>
<opcode name="f2d_aligned" group="Conversion operators">
<operation>Convert <code>native float</code> to <code>float64</code>,
aligned on a stack word boundary</operation>

<format>prefix<fsep/>f2d_aligned</format>
<dformat>{f2d_aligned}</dformat>

<form name="f2d_aligned" code="COP_PREFIX_F2D_ALIGNED"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>native float</code>.  The <code>float64</code> <i>result</i>
is formed by truncating <i>value</i> to 64 bits.  The <i>result</i>
is stored in the top-most stack position so that it is aligned
with the beginning of the stack word.</description>

<notes>This instruction is used to align a value prior to boxing
it with the <i>box</i> instruction.<p/>

The <code>float64</code> type may occupy less stack words than
the original <code>native float</code> value.  Excess stack words
are popped from the stack.</notes>
</opcode>
<opcode name="str2ansi" group="Conversion operators">
<operation>Convert <code>string</code> to <code>ansi char *</code>
</operation>

<format>prefix<fsep/>str2ansi</format>
<dformat>{str2ansi}</dformat>

<form name="str2ansi" code="COP_PREFIX_STR2ANSI"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>string</code>.  The string is converted into a
<i>result</i> character buffer using the underlying platform's
current locale settings.  A pointer to the buffer is pushed onto
the stack as type <code>ptr</code>.</description>

<notes>This instruction is used to convert C# strings into
character buffers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="str2utf8" group="Conversion operators">
<operation>Convert <code>string</code> to <code>utf8 char *</code>
</operation>

<format>prefix<fsep/>str2utf8</format>
<dformat>{str2utf8}</dformat>

<form name="str2utf8" code="COP_PREFIX_STR2UTF8"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>string</code>.  The string is converted into a
<i>result</i> character buffer using the UTF-8 encoding.
A pointer to the buffer is pushed onto the stack as type
<code>ptr</code>.</description>

<notes>This instruction is used to convert C# strings into
character buffers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="ansi2str" group="Conversion operators">
<operation>Convert <code>ansi char *</code> to <code>string</code>
</operation>

<format>prefix<fsep/>ansi2str</format>
<dformat>{ansi2str}</dformat>

<form name="ansi2str" code="COP_PREFIX_ANSI2STR"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  This pointer is interpreted as a
character buffer that uses the platform's current locale
settings.  This buffer is converted into a string <i>result</i>,
which is then pushed onto the stack as type <code>ptr</code>.
</description>

<notes>This instruction is used to convert character buffers into
C# strings during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="utf82str" group="Conversion operators">
<operation>Convert <code>utf8 char *</code> to <code>string</code>
</operation>

<format>prefix<fsep/>utf82str</format>
<dformat>{utf82str}</dformat>

<form name="utf82str" code="COP_PREFIX_UTF82STR"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>string</code>.  The string is converted into a
<i>result</i>.  character buffer using the UTF-8 encoding.
A pointer to the buffer is pushed onto the stack as type
<code>ptr</code>.</description>

<notes>This instruction is used to convert C# strings into
character buffers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="str2utf16" group="Conversion operators">
<operation>Convert <code>string</code> to <code>utf16 char *</code>
</operation>

<format>prefix<fsep/>str2utf16</format>
<dformat>{str2utf16}</dformat>

<form name="str2utf16" code="COP_PREFIX_STR2UTF16"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>string</code>.  The string is converted into a
<i>result</i> wide character buffer using the UTF-16 encoding.
A pointer to the buffer is pushed onto the stack as type
<code>ptr</code>.</description>

<notes>This instruction is used to convert C# strings into wide
character buffers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="utf162str" group="Conversion operators">
<operation>Convert <code>utf16 char *</code> to <code>string</code>
</operation>

<format>prefix<fsep/>utf162str</format>
<dformat>{utf162str}</dformat>

<form name="utf162str" code="COP_PREFIX_UTF162STR"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>utf16 char *</code>.  The wide character buffer
is converted into a <i>result</i> of type <code>string</code>,
which is pushed onto the stack.</description>

<notes>This instruction is used to convert wide character buffers
into C# strings during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="delegate2fnptr" group="Conversion operators">
<operation>Convert a delegate into a function pointer</operation>

<format>prefix<fsep/>delegate2fnptr</format>
<dformat>{delegate2fnptr}</dformat>

<form name="delegate2fnptr" code="COP_PREFIX_DELEGATE2FNPTR"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>delegate</code>.  The value is wrapped in a native
closure to make it suitable for use as a C function pointer.
The wrapped <i>result</i> is pushed onto the stack as type
<code>ptr</code>.</description>

<notes>This instruction is used to convert C# delegates into
C function pointers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="array2ptr" group="Conversion operators">
<operation>Convert an array into a pointer to its
first element</operation>

<format>prefix<fsep/>array2ptr</format>
<dformat>{array2ptr}</dformat>

<form name="array2ptr" code="COP_PREFIX_ARRAY2PTR"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  If <i>value</i> is not <code>null</code>,
a pointer to the first element in the array is computed as
<i>result</i>.  The <i>result</i> is pushed onto the stack
as type <code>ptr</code>.</description>

<notes>This instruction is used to convert C# arrays into
C pointers during "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="refarray2ansi" group="Conversion operators">
<operation>Convert a reference to an array of strings into
a pointer to an array of <code>ansi char *</code>
values</operation>

<format>prefix<fsep/>refarray2ansi</format>
<dformat>{refarray2ansi}</dformat>

<form name="refarray2ansi" code="COP_PREFIX_REFARRAY2ANSI"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The <code>String[]</code> object at
the address <i>value</i> is retrieved.  It is converted into
a NULL-terminated C array of the same size, with all of the
strings converted into the ANSI character encoding.  Then
a pointer to this array's reference is pushed as <i>result</i>.
</description>

<notes>This instruction is used to marshal parameters of type
<code>ref String[]</code> "PInvoke" marshalling operations.
It is primarily intended for use with Gtk#.</notes>
</opcode>
<opcode name="refarray2utf8" group="Conversion operators">
<operation>Convert a reference to an array of strings into
a pointer to an array of <code>utf8 char *</code>
values</operation>

<format>prefix<fsep/>refarray2utf8</format>
<dformat>{refarray2utf8}</dformat>

<form name="refarray2utf8" code="COP_PREFIX_REFARRAY2UTF8"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The <code>String[]</code> object at
the address <i>value</i> is retrieved.  It is converted into
a NULL-terminated C array of the same size, with all of the
strings converted into the UTF-8 character encoding.  Then
a pointer to this array's reference is pushed as <i>result</i>.
</description>

<notes>This instruction is used to marshal parameters of type
<code>ref String[]</code> "PInvoke" marshalling operations.
It is primarily intended for use with Gtk#.</notes>
</opcode>
<opcode name="array2ansi" group="Conversion operators">
<operation>Convert an array of strings into an array of
<code>ansi char *</code> values</operation>

<format>prefix<fsep/>array2ansi</format>
<dformat>{array2ansi}</dformat>

<form name="array2ansi" code="COP_PREFIX_ARRAY2ANSI"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The <code>String[]</code> object at
the address <i>value</i> is retrieved.  It is converted into
a NULL-terminated C array of the same size, with all of the
strings converted into the ANSI character encoding.  Then
a pointer to this array is pushed as <i>result</i>.
</description>

<notes>This instruction is used to marshal parameters of type
<code>String[]</code> "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="array2utf8" group="Conversion operators">
<operation>Convert an array of strings into an array of
<code>utf8 char *</code> values</operation>

<format>prefix<fsep/>array2utf8</format>
<dformat>{array2utf8}</dformat>

<form name="array2utf8" code="COP_PREFIX_ARRAY2UTF8"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The <code>String[]</code> object at
the address <i>value</i> is retrieved.  It is converted into
a NULL-terminated C array of the same size, with all of the
strings converted into the UTF8 character encoding.  Then
a pointer to this array is pushed as <i>result</i>.
</description>

<notes>This instruction is used to marshal parameters of type
<code>String[]</code> "PInvoke" marshalling operations.</notes>
</opcode>
<opcode name="tocustom" group="Conversion operators">
<operation>Convert an object reference into a custom native
pointer</operation>

<format>prefix<fsep/>tocustom<fsep/>len1[4]<fsep/>len2[4]<fsep/>name1<fsep/>name2</format>
<dformat>{tocustom}<fsep/>len1<fsep/>len2<fsep/>name1<fsep/>name2</dformat>

<form name="tocustom" code="COP_PREFIX_TOCUSTOM"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The custom marshaler called <i>name1</i>,
with cookie <i>name2</i> is used to convert <i>value</i> into a
native pointer <i>result</i>.  The values <i>len1</i> and <i>len2</i>
are the lengths of <i>name1</i> and <i>name2</i>.
</description>

<notes>This instruction is used to perform custom marshaling
during "PInvoke" operations.</notes>
</opcode>
<opcode name="fromcustom" group="Conversion operators">
<operation>Convert a custom native pointer into an object
reference</operation>

<format>prefix<fsep/>fromcustom<fsep/>len1[4]<fsep/>len2[4]<fsep/>name1<fsep/>name2</format>
<dformat>{fromcustom}<fsep/>len1<fsep/>len2<fsep/>name1<fsep/>name2</dformat>

<form name="fromcustom" code="COP_PREFIX_FROMCUSTOM"/>

<before>..., value</before>
<after>..., result</after>

<description>The <i>value</i> is popped from the stack as
type <code>ptr</code>.  The custom marshaler called <i>name1</i>,
with cookie <i>name2</i>, is used to convert <i>value</i> into an
object reference <i>result</i>.  The values <i>len1</i> and <i>len2</i>
are the lengths of <i>name1</i> and <i>name2</i>.
</description>

<notes>This instruction is used to perform custom marshaling
during "PInvoke" operations.</notes>
</opcode>
<opcode name="struct2native" group="Conversion operators">
<operation>Convert a struct into its native form</operation>

<format>prefix<fsep/>struct2native<fsep/>type</format>
<dformat>{struct2native}<fsep/>type</dformat>

<form name="struct2native" code="COP_PREFIX_STRUCT2NATIVE"/>

<before>..., ptr</before>
<after>...</after>

<description>The structured value at <i>ptr</i> is converted from
its managed form into its native form, converting field values
as appropriate.</description>
</opcode>
<opcode name="fix_i4_i" group="Conversion operators">
<operation>Convert a <code>int32</code>/<code>native int</code> pair
of values into <code>native int</code>/<code>native int</code></operation>

<format>prefix<fsep/>fix_i4_i</format>
<dformat>{fix_i4_i}</dformat>

<form name="fix_i4_i" code="COP_PREFIX_FIX_I4_I"/>

<before>..., value1, value2</before>
<after>..., result, value2</after>

<description>Both <i>value1</i> and <i>value2</i> are popped from
the stack as types <code>int32</code> and <code>native int</code>
respectively.  The <code>native int</code> <i>result</i> is formed
by sign-extending <i>value1</i>.  Then, <i>result</i> and <i>value2</i>
are pushed onto the stack.</description>

<notes>This is typically used to promote CIL I4 values to I when
used with a binary arithmetic operation.<p/>

On 32-bit platforms, this instruction will typically do nothing
because the <code>int32</code> and <code>native int</code> types
will be identical.<p/>

There is no <i>fix_i_i4</i> instruction because <i>i2l</i> can
be used to acheive the same result on 64-bit platforms.</notes>
</opcode>
<opcode name="fix_i4_u" group="Conversion operators">
<operation>Convert a <code>uint32</code>/<code>native uint</code> pair of
values into <code>native uint</code>/<code>native uint</code></operation>

<format>prefix<fsep/>fix_i4_u</format>
<dformat>{fix_i4_u}</dformat>

<form name="fix_i4_u" code="COP_PREFIX_FIX_I4_U"/>

<before>..., value1, value2</before>
<after>..., result, value2</after>

<description>Both <i>value1</i> and <i>value2</i> are popped from
the stack as types <code>uint32</code> and <code>native uint</code>
respectively.  The <code>native uint</code> <i>result</i> is formed
by zero-extending <i>value1</i>.  Then, <i>result</i> and <i>value2</i>
are pushed onto the stack.</description>

<notes>This is typically used to promote CIL I4 values to U when
used with a binary arithmetic operation.<p/>

On 32-bit platforms, this instruction will typically do nothing
because the <code>uint32</code> and <code>native uint</code> types
will be identical.<p/>

There is no <i>fix_u_i4</i> instruction because <i>iu2l</i> can
be used to acheive the same result on 64-bit platforms.</notes>
</opcode>
<opcode name="jsr" group="Exception handling instructions">
<operation>Jump to local subroutine</operation>

<format>jsr<fsep/>offset<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<format>br_long<fsep/>jsr
<fsep/>offset1<fsep/>offset2<fsep/>offset3<fsep/>offset4</format>
<dformat>{jsr}<fsep/>dest</dformat>

<form name="jsr" code="COP_JSR"/>

<before>...</before>
<after>..., address</after>

<description>The program counter for the next instruction (<i>pc + 6</i>)
is pushed on the stack as type <code>ptr</code>.  Then the program
branches to <i>pc + offset</i>.</description>

<notes>This instruction is used to implement <code>finally</code>
blocks.</notes>
</opcode>
<opcode name="ret_jsr" group="Exception handling instructions">
<operation>Return from local subroutine</operation>

<format>ret_jsr</format>
<dformat>{ret_jsr}</dformat>

<form name="ret_jsr" code="COP_RET_JSR"/>

<before>..., address</before>
<after>...</after>

<description>The <i>address</i> is popped from the stack as the
type <code>ptr</code> and transferred into <i>pc</i>.</description>

<notes>This instruction is used to implement <code>finally</code>
blocks.</notes>
</opcode>
<opcode name="enter_try" group="Exception handling instructions">
<operation>Enter <code>try</code> context for the
current method</operation>

<format>prefix<fsep/>enter_try</format>
<dformat>{enter_try}</dformat>

<form name="enter_try" code="COP_PREFIX_ENTER_TRY"/>

<description>The exception frame height for the current method
is set to the current height of the stack.</description>

<notes>This must be in the prolog of any method that includes
<code>try</code> blocks.  It sets the "base height" of the stack
so that <i>throw</i> instructions know where to unwind the stack
to when an exception is thrown.</notes>
</opcode>
<opcode name="throw" group="Exception handling instructions">
<operation>Throw an exception</operation>

<format>prefix<fsep/>throw</format>
<dformat>{throw}</dformat>

<form name="throw" code="COP_PREFIX_THROW"/>

<before>..., working1, ..., workingN, object</before>
<after>..., object</after>

<description>The <i>object</i> is popped from the stack as
type <code>ptr</code>.  The stack is then reset to the same
as the current method's exception frame height.  Then,
<i>object</i> is re-pushed onto the stack and control is
passed to the current method's exception matching code.</description>

<notes>This is used to throw exceptions within methods that
have an <i>enter_try</i> instruction.  Use <i>throw_caller</i>
if the method does not include <code>try</code> blocks.<p/>

Setting the stack height to the exception frame height ensures
that all working values are removed from the stack prior to entering
the exception matching code.</notes>
</opcode>
<opcode name="throw_caller" group="Exception handling instructions">
<operation>Throw an exception to the caller of this method</operation>

<format>prefix<fsep/>throw_caller</format>
<dformat>{throw_caller}</dformat>

<form name="throw_caller" code="COP_PREFIX_THROW_CALLER"/>

<before>..., working1, ..., workingN, object</before>
<after>..., object</after>

<description>The <i>object</i> is popped from the stack as
type <code>ptr</code>.  The call frame stack is then unwound
until a call frame with a non-zero exception frame height is found.
The stack is then reset to the specified exception frame height.
Then, <i>object</i> is re-pushed onto the stack and control is
passed to the call frame method's exception matching code.</description>

<notes>This is used to throw exceptions from within methods that
do not have an <i>enter_try</i> instruction.  Use <i>throw</i>
if the method does include <code>try</code> blocks.</notes>
</opcode>
<opcode name="set_stack_trace" group="Exception handling instructions">
<operation>Set the stack trace in an exception object at
the throw point</operation>

<format>prefix<fsep/>set_stack_trace</format>
<dformat>{set_stack_trace}</dformat>

<form name="set_stack_trace" code="COP_PREFIX_SET_STACK_TRACE"/>

<before>..., object</before>
<after>..., object</after>

<description>The <i>object</i> is popped from the stack as
type <code>ptr</code>; information about the current method's
stack calling context is written into <i>object</i>; and then
<i>object</i> is pushed back onto the stack.</description>

<notes>This opcode will have no effect if <i>object</i> is
<code>null</code>, or if its class does not inherit from
<code>System.Exception</code>.</notes>
</opcode>
<opcode name="start_catch" group="Exception handling instructions">
<operation>Save state information for Thread.Abort</operation>

<format>prefix<fsep/>start_catch</format>
<dformat>{set_stack_trace}</dformat>

<form name="set_stack_trace" code="COP_PREFIX_START_CATCH"/>

<before>...</before>
<after>...</after>

<description>
If the thread is aborting and a <code>ThreadAbortException</code>
has been thrown then save the current point where the
<code>ThreadAbortException</code> was thrown.
If the thread is aborting and the current exception isn't a
ThreadAbortException then reset the current exception to
ThreadAbortException.  This happens if a thread throws an
exception while it is being aborted (usually occurs in a finally clause).
</description>
</opcode>
<opcode name="start_finally" group="Exception handling instructions">
<operation>Save state information for Thread.Abort</operation>

<format>prefix<fsep/>start_finally</format>
<dformat>{set_stack_trace}</dformat>

<form name="set_stack_trace" code="COP_PREFIX_START_FINALLY"/>

<before>...</before>
<after>...</after>

<description>
If the thread is aborting and a <code>ThreadAbortException</code>
has been thrown then save the current point where the
<code>ThreadAbortException</code> was thrown.
</description>
</opcode>
<opcode name="propagate_abort" group="Exception handling instructions">
<operation>Propagate ThreadAbortExceptions</operation>

<format>prefix<fsep/>propagate_abort</format>

<form name="propagate_abort" code="COP_PREFIX_PROPAGATE_ABORT"/>

<before>...</before>
<after>...</after>

<description>
Check if the thread is aborting and propagate the ThreadAbortException
if the thread is at the end (or past) the catch or finally clause that
first detected the exception.
</description>
</opcode>
<opcode name="string_concat_2" group="Inline methods">
<operation>Concatenate two strings</operation>

<format>prefix<fsep/>string_concat_2</format>
<dformat>{string_concat_2}</dformat>

<form name="string_concat_2" code="COP_PREFIX_STRING_CONCAT_2"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>string</code>.  The <i>result</i>
is the <code>string</code> that results from concatenating
<i>value1</i> and <i>value2</i>.  The <i>result</i> is pushed
onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>String.Concat(String, String)</code> method.</notes>
</opcode>
<opcode name="string_concat_3" group="Inline methods">
<operation>Concatenate three strings</operation>

<format>prefix<fsep/>string_concat_3</format>
<dformat>{string_concat_3}</dformat>

<form name="string_concat_3" code="COP_PREFIX_STRING_CONCAT_3"/>

<before>..., value1, value2, value3</before>
<after>..., result</after>

<description>The values <i>value1</i>, <i>value2</i>, and <i>value3</i>
are popped from the stack as type <code>string</code>.  The <i>result</i>
is the <code>string</code> that results from concatenating
<i>value1</i>, <i>value2</i>, and <i>value3</i>.  The <i>result</i>
is pushed onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>String.Concat(String, String, String)</code> method.</notes>
</opcode>
<opcode name="string_concat_4" group="Inline methods">
<operation>Concatenate four strings</operation>

<format>prefix<fsep/>string_concat_4</format>
<dformat>{string_concat_4}</dformat>

<form name="string_concat_4" code="COP_PREFIX_STRING_CONCAT_4"/>

<before>..., value1, value2, value3, value4</before>
<after>..., result</after>

<description>The values <i>value1</i>, <i>value2</i>, <i>value3</i>,
and <i>value4</i> are popped from the stack as type <code>string</code>.
The <i>result</i> is the <code>string</code> that results from
concatenating <i>value1</i>, <i>value2</i>, <i>value3</i>, and
<i>value4</i>.  The <i>result</i> is pushed onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>String.Concat(String, String, String, String)</code> method.</notes>
</opcode>
<opcode name="string_eq" group="Inline methods">
<operation>Test two strings for equality</operation>

<format>prefix<fsep/>string_eq</format>
<dformat>{string_eq}</dformat>

<form name="string_eq" code="COP_PREFIX_STRING_EQ"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>string</code>.  The <i>result</i>
is the <code>int32</code> that results from comparing
<i>value1</i> and <i>value2</i>: 1 if they are equal, and 0
if they are not equal.  The <i>result</i> is pushed
onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>String.op_Equality(String, String)</code> method.</notes>
</opcode>
<opcode name="string_ne" group="Inline methods">
<operation>Test two strings for inequality</operation>

<format>prefix<fsep/>string_ne</format>
<dformat>{string_ne}</dformat>

<form name="string_ne" code="COP_PREFIX_STRING_NE"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as type <code>string</code>.  The <i>result</i>
is the <code>int32</code> that results from comparing
<i>value1</i> and <i>value2</i>: 1 if they are not equal, and 0
if they are equal.  The <i>result</i> is pushed
onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>String.op_Inequality(String, String)</code> method.</notes>
</opcode>
<opcode name="string_get_char" group="Inline methods">
<operation>Get a particular character from a string</operation>

<format>prefix<fsep/>string_get_char</format>
<dformat>{string_get_char}</dformat>

<form name="string_get_char" code="COP_PREFIX_STRING_GET_CHAR"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Both <i>value1</i> and <i>value2</i> are popped
from the stack as the types <code>string</code> and <code>int32</code>
respectively.  The <i>result</i> is the <code>int32</code> that
results from fetching the character at position <i>value2</i>
within the string <i>value1</i>.
<code>System.IndexOutOfRangeException</code> will be thrown if
<i>value2</i> is an invalid index.</description>

<notes>This instruction is used to inline calls to the
<code>String.get_Chars(int)</code> method.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>value1</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>value2</i> is not a valid character index for the string
<i>value1</i>.</exception>
</exceptions>
</opcode>
<opcode name="type_from_handle" group="Inline methods">
<operation>Get a type object from its runtime handle</operation>

<format>prefix<fsep/>type_from_handle</format>
<dformat>{type_from_handle}</dformat>

<form name="type_from_handle" code="COP_PREFIX_TYPE_FROM_HANDLE"/>

<before>..., handle</before>
<after>..., object</after>

<description>The <i>handle</i> is popped from the stack as the
type <code>ptr</code>.  It is interpreted as an instance of
the value type <code>System.RuntimeTypeHandle</code>.  The
<i>handle</i> is converted into an <i>object</i> instance
of the reference type <code>System.Type</code>.  The <i>object</i>
is pushed onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>Type.GetTypeFromHandle(RuntimeTypeHandle)</code> method.</notes>
</opcode>
<opcode name="monitor_enter" group="Inline methods">
<operation>Enter a monitor on an object</operation>

<format>prefix<fsep/>monitor_enter</format>
<dformat>{monitor_enter}</dformat>

<form name="monitor_enter" code="COP_PREFIX_MONITOR_ENTER"/>

<before>..., object</before>
<after>...</after>

<description>The <i>object</i> is popped from the stack as the
type <code>ptr</code>.  The current thread is made to enter the
synchronisation monitor on <i>object</i>.  Execution continues
once the monitor has been acquired.</description>

<notes>This instruction is used to inline calls to the
<code>Monitor.Enter(Object)</code> method.</notes>
</opcode>
<opcode name="monitor_exit" group="Inline methods">
<operation>Exit a monitor on an object</operation>

<format>prefix<fsep/>monitor_exit</format>
<dformat>{monitor_exit}</dformat>

<form name="monitor_exit" code="COP_PREFIX_MONITOR_EXIT"/>

<before>..., object</before>
<after>...</after>

<description>The <i>object</i> is popped from the stack as the
type <code>ptr</code>.  The current thread is made to exit the
synchronisation monitor on <i>object</i>.  Execution continues
once the monitor has been released.</description>

<notes>This instruction is used to inline calls to the
<code>Monitor.Exit(Object)</code> method.</notes>
</opcode>
<opcode name="append_char" group="Inline methods">
<operation>Append a character to a string builder</operation>

<format>prefix<fsep/>append_char<fsep/>method</format>
<dformat>{append_char}<fsep/>method</dformat>

<form name="append_char" code="COP_PREFIX_APPEND_CHAR"/>

<before>..., builder, ch</before>
<after>..., builder</after>

<description>The <i>builder</i> and <i>ch</i> are popped from the
stack as the types <code>ptr</code> and <code>int32</code> respectively.
The character <i>ch</i> is appended to the end of the string builder
indicated by <i>builder</i>.  The <i>builder</i> is then pushed
back onto the stack.</description>

<notes>This instruction is used to inline calls to the
<code>StringBuilder.Append(char)</code> method.  The <i>method</i>
argument must be a pointer to this method, because the interpreter
will "bail out" to the C# class library if the append is too
difficult to perform (e.g. the string must be reallocated).</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>builder</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="is_white_space" group="Inline methods">
<operation>Determine if a character is white space</operation>

<format>prefix<fsep/>is_white_space</format>
<dformat>{is_white_space}</dformat>

<form name="is_white_space" code="COP_PREFIX_IS_WHITE_SPACE"/>

<before>..., ch</before>
<after>..., result</after>

<description>The <i>ch</i> is popped from the stack as the
type <code>int32</code>.  If it is a white space character,
then the <code>int32</code> <i>result</i> 1 is pushed onto
the stack; otherwise 0 is pushed.</description>

<notes>This instruction is used to inline calls to the
<code>Char.IsWhiteSpace(char)</code> method, which is used
heavily in text processing code.</notes>
</opcode>
<opcode name="abs_i4" group="Inline methods">
<operation>Compute the absolute value of an int</operation>

<format>prefix<fsep/>abs_i4</format>
<dformat>{abs_i4}</dformat>

<form name="abs_i4" code="COP_PREFIX_ABS_I4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="min_i4" group="Inline methods">
<operation>Compute the minimum of two numbers</operation>

<format>prefix<fsep/>min_i4</format>
<dformat>{min_i4}</dformat>

<form name="min_i4" code="COP_PREFIX_MIN_I4"/>

<before>..., int</before>
<after>..., result</after>
</opcode>
<opcode name="max_i4" group="Inline methods">
<operation>Compute the maximum of two numbers</operation>

<format>prefix<fsep/>max_i4</format>
<dformat>{min_i4}</dformat>

<form name="max_i4" code="COP_PREFIX_MAX_I4"/>

<before>...,  int</before>
<after>..., result</after>
</opcode>
<opcode name="sign_i4" group="Inline methods">
<operation>Compute the sign of an int</operation>

<format>prefix<fsep/>sign_i4</format>
<dformat>{sign_i4}</dformat>

<form name="sign_i4" code="COP_PREFIX_SIGN_I4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="asin" group="Inline methods">
<operation>Compute the angle whose sine is the specified number</operation>

<format>prefix<fsep/>asin</format>
<dformat>{asin}</dformat>

<form name="asin" code="COP_PREFIX_ASIN"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="atan" group="Inline methods">
<operation>Compute the angle whose tangent is the specified number</operation>

<format>prefix<fsep/>atan</format>
<dformat>{atan}</dformat>

<form name="atan" code="COP_PREFIX_ATAN"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="atan2" group="Inline methods">
<operation>Compute the angle whose tangent is quotient of the two specified numbers</operation>

<format>prefix<fsep/>atan2</format>
<dformat>{atan2}</dformat>

<form name="atan2" code="COP_PREFIX_ATAN"/>

<before>..., number1, number2</before>
<after>..., result</after>
</opcode>
<opcode name="ceiling" group="Inline methods">
<operation>Returns the smallest whole number greater than or equal to the specified number</operation>

<format>prefix<fsep/>ceiling</format>
<dformat>{ceiling}</dformat>

<form name="ceiling" code="COP_PREFIX_CEILING"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="cos" group="Inline methods">
<operation>Compute the cosine of the specified angle</operation>

<format>prefix<fsep/>cos</format>
<dformat>{cos}</dformat>

<form name="cos" code="COP_PREFIX_COS"/>

<before>..., angle</before>
<after>..., result</after>
</opcode>
<opcode name="cosh" group="Inline methods">
<operation>Returns the hyperbolic cosine of the specified angle</operation>

<format>prefix<fsep/>cosh</format>
<dformat>{cosh}</dformat>

<form name="cosh" code="COP_PREFIX_COSH"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="exp" group="Inline methods">
<operation>Computes e raised to the specified power</operation>

<format>prefix<fsep/>exp</format>
<dformat>{exp}</dformat>

<form name="exp" code="COP_PREFIX_EXP"/>

<before>..., power</before>
<after>..., result</after>
</opcode>
<opcode name="floor" group="Inline methods">
<operation>Computes the largest whole number less than or equal to the specified number</operation>

<format>prefix<fsep/>floor</format>
<dformat>{floor}</dformat>

<form name="floor" code="COP_PREFIX_FLOOR"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="ieeeremainder" group="Inline methods">
<operation>Computes the remainder resulting from the division of
a specified number by another specified number.</operation>

<format>prefix<fsep/>ieeeremainder</format>
<dformat>{ieeeremainder}</dformat>

<form name="ieeeremainder" code="COP_PREFIX_IEEEREMAINDER"/>

<before>..., number1, number2</before>
<after>..., result</after>
</opcode>
<opcode name="log" group="Inline methods">
<operation>Computes the natural (base e) logarithm of the specified number</operation>

<format>prefix<fsep/>log</format>
<dformat>{log}</dformat>

<form name="log" code="COP_PREFIX_LOG"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="log10" group="Inline methods">
<operation>Computes the base 10 logarithm of the specified number</operation>

<format>prefix<fsep/>log10</format>
<dformat>{log10}</dformat>

<form name="log10" code="COP_PREFIX_LOG10"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="pow" group="Inline methods">
<operation>Computes the given number raised to a specific power</operation>

<format>prefix<fsep/>pow</format>
<dformat>{pow}</dformat>

<form name="pow" code="COP_PREFIX_POW"/>

<before>..., number, power</before>
<after>..., result</after>
</opcode>
<opcode name="round" group="Inline methods">
<operation>Computes the whole number nearest to the specified number</operation>

<format>prefix<fsep/>round</format>
<dformat>{round}</dformat>

<form name="round" code="COP_PREFIX_ROUND"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="sin" group="Inline methods">
<operation>Compute the sine of the specified angle</operation>

<format>prefix<fsep/>sin</format>
<dformat>{sin}</dformat>

<form name="sin" code="COP_PREFIX_SIN"/>

<before>..., angle</before>
<after>..., result</after>
</opcode>
<opcode name="sinh" group="Inline methods">
<operation>Computes the hyperbolic sine of the specified angle</operation>

<format>prefix<fsep/>sinh</format>
<dformat>{sinh}</dformat>

<form name="sinh" code="COP_PREFIX_SINH"/>

<before>..., angle</before>
<after>..., result</after>
</opcode>
<opcode name="sqrt" group="Inline methods">
<operation>Computes the square root of the specified number</operation>

<format>prefix<fsep/>sqrt</format>
<dformat>{sqrt}</dformat>

<form name="sqrt" code="COP_PREFIX_SQRT"/>

<before>..., number</before>
<after>..., result</after>
</opcode>
<opcode name="tan" group="Inline methods">
<operation>Computes the tangent of the specified angle</operation>

<format>prefix<fsep/>tan</format>
<dformat>{tan}</dformat>

<form name="tan" code="COP_PREFIX_TAN"/>

<before>..., angle</before>
<after>..., result</after>
</opcode>
<opcode name="tanh" group="Inline methods">
<operation>Computes the hyperbolic tangent of the specified angle</operation>

<format>prefix<fsep/>tanh</format>
<dformat>{tanh}</dformat>

<form name="tanh" code="COP_PREFIX_TANH"/>

<before>..., angle</before>
<after>..., result</after>
</opcode>
<opcode name="min_r4" group="Inline methods">
<operation>Compute the minimum of two numbers</operation>

<format>prefix<fsep/>min_r4</format>
<dformat>{min_r4}</dformat>

<form name="min_r4" code="COP_PREFIX_MIN_R4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="max_r4" group="Inline methods">
<operation>Compute the maximum of two floats</operation>

<format>prefix<fsep/>max_r4</format>
<dformat>{max_r4}</dformat>

<form name="max_r4" code="COP_PREFIX_MAX_R4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="min_r8" group="Inline methods">
<operation>Compute the minimum of two doubles</operation>

<format>prefix<fsep/>min_r8</format>
<dformat>{min_r8}</dformat>

<form name="min_r8" code="COP_PREFIX_MIN_R8"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="max_r8" group="Inline methods">
<operation>Compute the maximum of two doubles</operation>

<format>prefix<fsep/>max_r8</format>
<dformat>{max_r8}</dformat>

<form name="max_r8" code="COP_PREFIX_MAX_R8"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="sign_r4" group="Inline methods">
<operation>Compute the sign of a float</operation>

<format>prefix<fsep/>sign_r4</format>
<dformat>{sign_r4}</dformat>

<form name="sign_r4" code="COP_PREFIX_SIGN_R4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="sign_r8" group="Inline methods">
<operation>Compute the sign of a double</operation>

<format>prefix<fsep/>sign_r8</format>
<dformat>{sign_r8}</dformat>

<form name="sign_r8" code="COP_PREFIX_SIGN_R8"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="abs_r4" group="Inline methods">
<operation>Compute the absolute value of a float</operation>

<format>prefix<fsep/>abs_r4</format>
<dformat>{abs_r4}</dformat>

<form name="abs_r4" code="COP_PREFIX_ABS_R4"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="abs_r8" group="Inline methods">
<operation>Compute the absolute value of a double</operation>

<format>prefix<fsep/>abs_r8</format>
<dformat>{abs_r8}</dformat>

<form name="abs_r8" code="COP_PREFIX_ABS_R8"/>

<before>..., db</before>
<after>..., result</after>
</opcode>
<opcode name="bread" group="Pointer handling">
<operation>Read <code>int8</code> from pointer</operation>

<format>bread</format>
<dformat>{bread}</dformat>

<form name="bread" code="COP_BREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 8 bit value at <i>pointer</i> in
memory, sign-extend it to <code>int32</code> and push it onto
the stack.</description>
</opcode>
<opcode name="ubread" group="Pointer handling">
<operation>Read <code>uint8</code> from pointer</operation>

<format>ubread</format>
<dformat>{ubread}</dformat>

<form name="ubread" code="COP_UBREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 8 bit value at <i>pointer</i> in
memory, zero-extend it to <code>int32</code> and push it onto
the stack.</description>
</opcode>
<opcode name="sread" group="Pointer handling">
<operation>Read <code>int16</code> from pointer</operation>

<format>sread</format>
<dformat>{sread}</dformat>

<form name="sread" code="COP_SREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 16 bit value at <i>pointer</i> in
memory, sign-extend it to <code>int32</code> and push it onto
the stack.</description>
</opcode>
<opcode name="usread" group="Pointer handling">
<operation>Read <code>uint16</code> from pointer</operation>

<format>usread</format>
<dformat>{usread}</dformat>

<form name="usread" code="COP_USREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 16 bit value at <i>pointer</i> in
memory, zero-extend it to <code>int32</code> and push it onto
the stack.</description>
</opcode>
<opcode name="iread" group="Pointer handling">
<operation>Read <code>int32</code> from pointer</operation>

<format>iread</format>
<dformat>{iread}</dformat>

<form name="iread" code="COP_IREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 32 bit <code>int32</code> value
at <i>pointer</i> in memory, and push it onto the stack.</description>

<notes>This instruction can also be used to read <code>uint32</code>
values from memory.</notes>
</opcode>
<opcode name="fread" group="Pointer handling">
<operation>Read <code>float32</code> from pointer</operation>

<format>fread</format>
<dformat>{fread}</dformat>

<form name="fread" code="COP_FREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 32 bit <code>float32</code> value
at <i>pointer</i> in memory, extend it to <code>native float</code>,
and push it onto the stack.</description>
</opcode>
<opcode name="dread" group="Pointer handling">
<operation>Read <code>float64</code> from pointer</operation>

<format>dread</format>
<dformat>{dread}</dformat>

<form name="dread" code="COP_DREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the 64 bit <code>float64</code> value
at <i>pointer</i> in memory, extend it to <code>native float</code>,
and push it onto the stack.</description>
</opcode>
<opcode name="pread" group="Pointer handling">
<operation>Read <code>ptr</code> from pointer</operation>

<format>pread</format>
<dformat>{pread}</dformat>

<form name="pread" code="COP_PREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read the <code>ptr</code> value
at <i>pointer</i> in memory, and push it onto the stack.</description>

<notes>This instruction must not be confused with <i>iread</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>
</opcode>
<opcode name="mread" group="Pointer handling">
<operation>Read multiple bytes from pointer</operation>

<format>mread<fsep/>N[1]</format>
<format>wide<fsep/>mread<fsep/>N[4]</format>
<dformat>{mread}<fsep/>N</dformat>

<form name="mread" code="COP_MREAD"/>

<before>..., pointer</before>
<after>..., value</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Read <i>N</i> bytes from <i>pointer</i>
in memory, and push them onto the stack, aligned on a word
boundary.</description>

<notes>The exact number of stack words that is pushed depends
upon the underlying platform.</notes>
</opcode>
<opcode name="bwrite" group="Pointer handling">
<operation>Write <code>int8</code> to pointer</operation>

<format>bwrite</format>
<dformat>{bwrite}</dformat>

<form name="bwrite" code="COP_BWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Truncate <i>value</i> to 8 bits and write it to <i>pointer</i> in
memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint8</code> to memory.</notes>
</opcode>
<opcode name="swrite" group="Pointer handling">
<operation>Write <code>int16</code> to pointer</operation>

<format>swrite</format>
<dformat>{swrite}</dformat>

<form name="swrite" code="COP_SWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Truncate <i>value</i> to 16 bits and write it to <i>pointer</i> in
memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint16</code> to memory.</notes>
</opcode>
<opcode name="iwrite" group="Pointer handling">
<operation>Write <code>int32</code> to pointer</operation>

<format>iwrite</format>
<dformat>{iwrite}</dformat>

<form name="iwrite" code="COP_IWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Write <i>value</i> to <i>pointer</i> in memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint32</code> to memory.</notes>
</opcode>
<opcode name="fwrite" group="Pointer handling">
<operation>Write <code>float32</code> to pointer</operation>

<format>fwrite</format>
<dformat>{fwrite}</dformat>

<form name="fwrite" code="COP_FWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>native float</code> respectively.
Truncate <i>value</i> to <code>float32</code> and write it
to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="dwrite" group="Pointer handling">
<operation>Write <code>float64</code> to pointer</operation>

<format>dwrite</format>
<dformat>{dwrite}</dformat>

<form name="dwrite" code="COP_DWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>native float</code> respectively.
Truncate <i>value</i> to <code>float64</code> and write it
to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="pwrite" group="Pointer handling">
<operation>Write <code>ptr</code> to pointer</operation>

<format>pwrite</format>
<dformat>{pwrite}</dformat>

<form name="pwrite" code="COP_PWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
type <code>ptr</code>.  Write <i>value</i> to <i>pointer</i>
in memory.</description>

<notes>This instruction must not be confused with <i>iwrite</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>
</opcode>
<opcode name="mwrite" group="Pointer handling">
<operation>Write multiple bytes to pointer</operation>

<format>mwrite<fsep/>N[1]</format>
<format>wide<fsep/>mwrite<fsep/>N[4]</format>
<dformat>{mwrite}<fsep/>N</dformat>

<form name="mwrite" code="COP_MWRITE"/>

<before>..., pointer, value</before>
<after>...</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>uint8[N]</code> (i.e. <i>N</i>
bytes of data, aligned on a stack word) respectively.  Write
<i>value</i> to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="bwrite_r" group="Pointer handling">
<operation>Write <code>int8</code> to pointer with reversed
arguments</operation>

<format>bwrite_r</format>
<dformat>{bwrite_r}</dformat>

<form name="bwrite_r" code="COP_BWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>int32</code> and <code>ptr</code> respectively.
Truncate <i>value</i> to 8 bits and write it to <i>pointer</i> in
memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint8</code> to memory.</notes>
</opcode>
<opcode name="swrite_r" group="Pointer handling">
<operation>Write <code>int16</code> to pointer with reversed
arguments</operation>

<format>swrite_r</format>
<dformat>{swrite_r}</dformat>

<form name="swrite_r" code="COP_SWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>int32</code> and <code>ptr</code> respectively.
Truncate <i>value</i> to 16 bits and write it to <i>pointer</i> in
memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint16</code> to memory.</notes>
</opcode>
<opcode name="iwrite_r" group="Pointer handling">
<operation>Write <code>int32</code> to pointer with reversed
arguments</operation>

<format>iwrite_r</format>
<dformat>{iwrite_r}</dformat>

<form name="iwrite_r" code="COP_IWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>int32</code> and <code>ptr</code> respectively.
Write <i>value</i> to <i>pointer</i> in memory.</description>

<notes>This instruction can also be used to write values of
type <code>uint32</code> to memory.</notes>
</opcode>
<opcode name="fwrite_r" group="Pointer handling">
<operation>Write <code>float32</code> to pointer with reversed
arguments</operation>

<format>fwrite_r</format>
<dformat>{fwrite_r}</dformat>

<form name="fwrite_r" code="COP_FWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>native float</code> and <code>ptr</code> respectively.
Truncate <i>value</i> to <code>float32</code> and write it
to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="dwrite_r" group="Pointer handling">
<operation>Write <code>float64</code> to pointer with reversed
arguments</operation>

<format>dwrite_r</format>
<dformat>{dwrite_r}</dformat>

<form name="dwrite_r" code="COP_DWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>native float</code> and <code>ptr</code> respectively.
Truncate <i>value</i> to <code>float64</code> and write it
to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="pwrite_r" group="Pointer handling">
<operation>Write <code>ptr</code> to pointer with reversed
arguments</operation>

<format>pwrite_r</format>
<dformat>{pwrite_r}</dformat>

<form name="pwrite_r" code="COP_PWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
type <code>ptr</code>.  Write <i>value</i> to <i>pointer</i>
in memory.</description>

<notes>This instruction must not be confused with <i>iwrite_r</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>
</opcode>
<opcode name="mwrite_r" group="Pointer handling">
<operation>Write multiple bytes to pointer with reversed
arguments</operation>

<format>mwrite_r<fsep/>N[1]</format>
<format>wide<fsep/>mwrite_r<fsep/>N[4]</format>
<dformat>{mwrite_r}<fsep/>N</dformat>

<form name="mwrite_r" code="COP_MWRITE_R"/>

<before>..., value, pointer</before>
<after>...</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack as
the types <code>uint8[N]</code> (i.e. <i>N</i> bytes of data,
aligned on a stack word) and <code>ptr</code> respectively.
Write <i>value</i> to <i>pointer</i> in memory.</description>
</opcode>
<opcode name="padd_offset" group="Pointer handling">
<operation>Add a literal byte offset to a pointer</operation>

<format>padd_offset<fsep/>N[1]</format>
<dformat>{padd_offset}<fsep/>N</dformat>

<form name="padd_offset" code="COP_PADD_OFFSET"/>

<before>..., pointer</before>
<after>..., newpointer</after>

<description>Pop <i>pointer</i> from the stack as type <code>ptr</code>.
Compute <i>newpointer = pointer + N</i> and push <i>newpointer</i>
onto the stack.</description>
</opcode>
<opcode name="padd_offset_n" group="Pointer handling">
<operation>Add a literal byte offset to a pointer that is
several words down the stack</operation>

<format>padd_offset_n<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>padd_offset_n<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{padd_offset_n}<fsep/>N<fsep/>M</dformat>

<form name="padd_offset_n" code="COP_PADD_OFFSET_N"/>

<before>..., pointer, val1, ..., valN</before>
<after>..., newpointer, val1, ..., valN</after>

<description>Read <i>pointer</i> from the <i>N</i> positions
down the stack as type <code>ptr</code>.  Compute
<i>newpointer = pointer + M</i> and replace <i>pointer</i>
with <i>newpointer</i>.  A value of <i>N == 0</i> indicates the
top-most stack word.</description>

<notes>The <i>padd_offset</i> instruction is more efficient if
<i>N == 0</i> and <i>M &lt; 256</i>.</notes>
</opcode>
<opcode name="padd_i4" group="Pointer handling">
<operation>Add <code>int32</code> value to pointer</operation>

<format>padd_i4</format>
<dformat>{padd_i4}</dformat>

<form name="padd_i4" code="COP_PADD_I4"/>

<before>..., pointer, value</before>
<after>..., newpointer</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack
as the types <code>ptr</code> and <code>int32</code> respectively.
Compute <i>newpointer = pointer + value</i> and push
<i>newpointer</i> onto the stack.</description>

<notes>The <i>padd_offset</i> instruction is more efficient if
<i>value</i> is constant and less than 256.</notes>
</opcode>
<opcode name="padd_i4_r" group="Pointer handling">
<operation>Add <code>int32</code> value to pointer with
reversed arguments</operation>

<format>padd_i4_r</format>
<dformat>{padd_i4_r}</dformat>

<form name="padd_i4_r" code="COP_PADD_I4_R"/>

<before>..., value, pointer</before>
<after>..., newpointer</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack
as the types <code>int32</code> and <code>ptr</code> respectively.
Compute <i>newpointer = pointer + value</i> and push
<i>newpointer</i> onto the stack.</description>
</opcode>
<opcode name="padd_i8" group="Pointer handling">
<operation>Add <code>int64</code> value to pointer</operation>

<format>padd_i8</format>
<dformat>{padd_i8}</dformat>

<form name="padd_i8" code="COP_PADD_I8"/>

<before>..., pointer, value</before>
<after>..., newpointer</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack
as the types <code>ptr</code> and <code>int64</code> respectively.
Compute <i>newpointer = pointer + value</i> and push
<i>newpointer</i> onto the stack.</description>

<notes>The <i>value</i> will be truncated to 32 bits on platforms
with 32 bit pointers.</notes>
</opcode>
<opcode name="padd_i8_r" group="Pointer handling">
<operation>Add <code>int64</code> value to pointer with
reversed arguments</operation>

<format>padd_i8_r</format>
<dformat>{padd_i8_r}</dformat>

<form name="padd_i8_r" code="COP_PADD_I8_R"/>

<before>..., value, pointer</before>
<after>..., newpointer</after>

<description>Pop <i>value</i> and <i>pointer</i> from the stack
as the types <code>int64</code> and <code>ptr</code> respectively.
Compute <i>newpointer = pointer + value</i> and push
<i>newpointer</i> onto the stack.</description>

<notes>The <i>value</i> will be truncated to 32 bits on platforms
with 32 bit pointers.</notes>
</opcode>
<opcode name="psub" group="Pointer handling">
<operation>Subtract pointer values</operation>

<format>psub</format>
<dformat>{psub}</dformat>

<form name="psub" code="COP_PSUB"/>

<before>..., value1, value2</before>
<after>..., result</after>

<description>Pop <i>value1</i> and <i>value2</i> from the stack
as type <code>ptr</code>.  Compute <i>result = value1 - value2</i>
and push <i>result</i> onto the stack.  The type of <i>result</i>
will be either <code>int32</code> or <code>int64</code>, depending
upon the platform.</description>
</opcode>
<opcode name="psub_i4" group="Pointer handling">
<operation>Subtract <code>int32</code> from pointer</operation>

<format>psub_i4</format>
<dformat>{psub_i4}</dformat>

<form name="psub_i4" code="COP_PSUB_I4"/>

<before>..., pointer, value</before>
<after>..., newpointer</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack
as the types <code>ptr</code> and <code>int32</code> respectively.
Compute <i>newpointer = pointer - value</i> and push
<i>newpointer</i> onto the stack.</description>
</opcode>
<opcode name="psub_i8" group="Pointer handling">
<operation>Subtract <code>int64</code> from pointer</operation>

<format>psub_i8</format>
<dformat>{psub_i8}</dformat>

<form name="psub_i8" code="COP_PSUB_I8"/>

<before>..., pointer, value</before>
<after>..., newpointer</after>

<description>Pop <i>pointer</i> and <i>value</i> from the stack
as the types <code>ptr</code> and <code>int64</code> respectively.
Compute <i>newpointer = pointer - value</i> and push
<i>newpointer</i> onto the stack.</description>

<notes>The <i>value</i> will be truncated to 32 bits on platforms
with 32 bit pointers.</notes>
</opcode>
<opcode name="cknull" group="Object handling">
<operation>Check pointer for <code>null</code></operation>

<format>cknull</format>
<dformat>{cknull}</dformat>

<form name="cknull" code="COP_CKNULL"/>

<before>..., pointer</before>
<after>..., pointer</after>

<description>Throw <code>System.NullReferenceException</code> if
the <code>ptr</code> value on the top of the stack is <code>null</code>.
Otherwise do nothing.</description>
</opcode>
<opcode name="cknull_n" group="Object handling">
<operation>Check pointer down the stack for <code>null</code></operation>

<format>cknull_n<fsep/>N[1]</format>
<format>wide<fsep/>cknull_n<fsep/>N[4]</format>
<dformat>{cknull_n}<fsep/>N</dformat>

<form name="cknull_n" code="COP_CKNULL_N"/>

<before>..., pointer, val1, ..., valN</before>
<after>..., pointer, val1, ..., valN</after>

<description>Throw <code>System.NullReferenceException</code> if
the <code>ptr</code> value <i>N</i> words down the stack is
<code>null</code>.  Otherwise do nothing.  <i>N == 0</i> indicates
the top of the stack.</description>

<notes>The <i>cknull</i> instruction is more efficient if
<i>N == 0</i>.</notes>
</opcode>
<opcode name="bread_elem" group="Array handling">
<operation>Read <code>int8</code> value from array</operation>

<format>bread_elem</format>
<dformat>{bread_elem}</dformat>

<form name="bread_elem" code="COP_BREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the 8 bit value from position <i>index</i>
in <i>array</i>, sign-extend it to <code>int32</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="ubread_elem" group="Array handling">
<operation>Read <code>uint8</code> value from array</operation>

<format>ubread_elem</format>
<dformat>{ubread_elem}</dformat>

<form name="ubread_elem" code="COP_UBREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the 8 bit value from position <i>index</i>
in <i>array</i>, zero-extend it to <code>int32</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="sread_elem" group="Array handling">
<operation>Read <code>int16</code> value from array</operation>

<format>sread_elem</format>
<dformat>{sread_elem}</dformat>

<form name="sread_elem" code="COP_SREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the 16 bit value from position <i>index</i>
in <i>array</i>, sign-extend it to <code>int32</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="usread_elem" group="Array handling">
<operation>Read <code>uint16</code> value from array</operation>

<format>usread_elem</format>
<dformat>{usread_elem}</dformat>

<form name="usread_elem" code="COP_USREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the 16 bit value from position <i>index</i>
in <i>array</i>, zero-extend it to <code>int32</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="iread_elem" group="Array handling">
<operation>Read <code>int32</code> value from array</operation>

<format>iread_elem</format>
<dformat>{iread_elem}</dformat>

<form name="iread_elem" code="COP_IREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the <code>int32</code> value from position
<i>index</i> and push it onto the stack.</description>

<notes>This instruction can also be used to read values of
type <code>uint32</code> from an array.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="pread_elem" group="Array handling">
<operation>Read <code>ptr</code> value from array</operation>

<format>pread_elem</format>
<dformat>{pread_elem}</dformat>

<form name="pread_elem" code="COP_PREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the <code>ptr</code> value from position
<i>index</i> and push it onto the stack.</description>

<notes>This instruction must not be confused with <i>iread_elem</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="bwrite_elem" group="Array handling">
<operation>Write <code>int8</code> value to array</operation>

<format>bwrite_elem</format>
<dformat>{bwrite_elem}</dformat>

<form name="bwrite_elem" code="COP_BWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int32</code> respectively.
The <i>value</i> is truncated to 8 bits and written at
position <i>index</i> in <i>array</i>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="swrite_elem" group="Array handling">
<operation>Write <code>int16</code> value to array</operation>

<format>swrite_elem</format>
<dformat>{swrite_elem}</dformat>

<form name="swrite_elem" code="COP_SWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int32</code> respectively.
The <i>value</i> is truncated to 16 bits and written at
position <i>index</i> in <i>array</i>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="iwrite_elem" group="Array handling">
<operation>Write <code>int32</code> value to array</operation>

<format>iwrite_elem</format>
<dformat>{iwrite_elem}</dformat>

<form name="iwrite_elem" code="COP_IWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int32</code> respectively.
The <i>value</i> is written at position <i>index</i>
in <i>array</i>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="pwrite_elem" group="Array handling">
<operation>Write <code>ptr</code> value to array</operation>

<format>pwrite_elem</format>
<dformat>{pwrite_elem}</dformat>

<form name="pwrite_elem" code="COP_PWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>ptr</code> respectively.
The <i>value</i> is written at position <i>index</i>
in <i>array</i>.</description>

<notes>This instruction must not be confused with <i>iwrite_elem</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="ckarray_load_i4" group="Array handling">
<operation>Check an array load with an <code>int32</code>
index</operation>

<format>ckarray_load_i4</format>
<dformat>{ckarray_load_i4}</dformat>

<form name="ckarray_load_i4" code="COP_CKARRAY_LOAD_I4"/>

<before>..., array, index</before>
<after>..., pointer, index</after>

<description>Retrieve <i>array</i> and <i>index</i>
from the stack (without popping them) as the types <code>ptr</code>
and <code>int32</code> respectively.  Throw a
<code>System.IndexOutOfRangeException</code> if <i>index</i> is
out of range.  Otherwise set <i>pointer</i> to the address of
the first element in the array.</description>

<notes>This instruction is used to assist in obtaining the address
of an array element.  The program will normally follow this
instruction with an <i>imul</i> operation to adjust the index
for the size of the elements, followed by <i>padd_i4</i> to compute
the final element address.  This instruction sequence can also be
used in combination with <i>mread</i> to fetch odd-sized array
elements by pointer.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="ckarray_load_i8" group="Array handling">
<operation>Check an array load with an <code>int64</code>
index</operation>

<format>ckarray_load_i8</format>
<dformat>{ckarray_load_i8}</dformat>

<form name="ckarray_load_i8" code="COP_CKARRAY_LOAD_I8"/>

<before>..., array, index</before>
<after>..., pointer, index</after>

<description>Retrieve <i>array</i> and <i>index</i>
from the stack (without popping them) as the types <code>ptr</code>
and <code>int64</code> respectively.  Throw a
<code>System.IndexOutOfRangeException</code> if <i>index</i> is
out of range.  Otherwise set <i>pointer</i> to the address of
the first element in the array.</description>

<notes>This instruction is used to assist in obtaining the address
of an array element.  The program will normally follow this
instruction with an <i>lmul</i> operation to adjust the index
for the size of the elements, followed by <i>padd_i8</i> to compute
the final element address.  This instruction sequence can also be
used in combination with <i>mread</i> to fetch odd-sized array
elements by pointer.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="ckarray_store_i8" group="Array handling">
<operation>Check an array store that uses an <code>int64</code>
index</operation>

<format>ckarray_store_i8<fsep/>N[1]<fsep/>M[1]</format>
<dformat>{ckarray_store_i8}<fsep/>N<fsep/>M</dformat>

<form name="ckarray_store_i8" code="COP_CKARRAY_STORE_I8"/>

<before>..., array, index, value</before>
<after>..., pointer, value</after>

<description>Pop <i>array</i>, <i>index</i>, and <i>value</i>
from the stack as the types <code>ptr</code>, <code>int64</code>,
and <code>word[N]</code> respectively (where <code>word</code>
is the type of a stack word).  Throw a
<code>System.IndexOutOfRangeException</code> if <i>index</i> is
out of range.  Otherwise set <i>pointer</i> to the address of
the <i>index</i>'th element in the array.  The size of each
array element is <i>M</i> bytes.  The <i>pointer</i> and
<i>value</i> are pushed onto the stack.</description>

<notes>This instruction is used to assist in storing an element
to an array when the CIL index had the type I on a 64-bit platform.
This instruction sequence is typically followed by a <i>*write</i>
instruction to store <i>value</i> at <i>pointer</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="array_len" group="Array handling">
<operation>Get the length of an array</operation>

<format>array_len</format>
<dformat>{array_len}</dformat>

<form name="array_len" code="COP_ARRAY_LEN"/>

<before>..., array</before>
<after>..., length</after>

<description>Pop <i>array</i> from the stack as type <code>ptr</code>.
Fetch the <i>length</i> of this array and push it onto the stack
as type <code>native int</code>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="bread_field" group="Object handling">
<operation>Read <code>int8</code> field</operation>

<format>bread_field<fsep/>N[1]</format>
<dformat>{bread_field}<fsep/>N</dformat>

<form name="bread_field" code="COP_BREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the 8 bit value at <i>object + N</i>, sign-extend it to
<code>int32</code>, and push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, bread</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="ubread_field" group="Object handling">
<operation>Read <code>uint8</code> field</operation>

<format>ubread_field<fsep/>N[1]</format>
<dformat>{ubread_field}<fsep/>N</dformat>

<form name="ubread_field" code="COP_UBREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the 8 bit value at <i>object + N</i>, zero-extend it to
<code>int32</code>, and push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, ubread</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="sread_field" group="Object handling">
<operation>Read <code>int16</code> field</operation>

<format>sread_field<fsep/>N[1]</format>
<dformat>{sread_field}<fsep/>N</dformat>

<form name="sread_field" code="COP_SREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the 16 bit value at <i>object + N</i>, sign-extend it to
<code>int32</code>, and push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, sread</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="usread_field" group="Object handling">
<operation>Read <code>uint16</code> field</operation>

<format>usread_field<fsep/>N[1]</format>
<dformat>{usread_field}<fsep/>N</dformat>

<form name="usread_field" code="COP_USREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the 16 bit value at <i>object + N</i>, zero-extend it to
<code>int32</code>, and push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, usread</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="iread_field" group="Object handling">
<operation>Read <code>int32</code> field</operation>

<format>iread_field<fsep/>N[1]</format>
<dformat>{iread_field}<fsep/>N</dformat>

<form name="iread_field" code="COP_IREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the <code>int32</code> value at <i>object + N</i>, and
push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, iread</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="pread_field" group="Object handling">
<operation>Read <code>ptr</code> field</operation>

<format>pread_field<fsep/>N[1]</format>
<dformat>{pread_field}<fsep/>N</dformat>

<form name="pread_field" code="COP_PREAD_FIELD"/>

<before>..., object</before>
<after>..., value</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
Fetch the <code>ptr</code> value at <i>object + N</i>, and
push it onto the stack.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull, ldc_i4 N, padd_i4, pread</i>.<p/>

This instruction must not be confused with <i>iread_field</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="bwrite_field" group="Object handling">
<operation>Write <code>int8</code> field</operation>

<format>bwrite_field<fsep/>N[1]</format>
<dformat>{bwrite_field}<fsep/>N</dformat>

<form name="bwrite_field" code="COP_BWRITE_FIELD"/>

<before>..., object, value</before>
<after>...</after>

<description>Pop <i>object</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Truncate <i>value</i> to 8 bits and store it at <i>object + N</i>.
</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull_n 1, padd_offset_n 1 N, bwrite</i>.<p/>

This instruction can also be used to write values of type
<code>uint8</code>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="swrite_field" group="Object handling">
<operation>Write <code>int16</code> field</operation>

<format>swrite_field<fsep/>N[1]</format>
<dformat>{swrite_field}<fsep/>N</dformat>

<form name="swrite_field" code="COP_SWRITE_FIELD"/>

<before>..., object, value</before>
<after>...</after>

<description>Pop <i>object</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Truncate <i>value</i> to 16 bits and store it at <i>object + N</i>.
</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull_n 1, padd_offset_n 1 N, swrite</i>.<p/>

This instruction can also be used to write values of type
<code>uint16</code>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="iwrite_field" group="Object handling">
<operation>Write <code>int32</code> field</operation>

<format>iwrite_field<fsep/>N[1]</format>
<dformat>{iwrite_field}<fsep/>N</dformat>

<form name="iwrite_field" code="COP_IWRITE_FIELD"/>

<before>..., object, value</before>
<after>...</after>

<description>Pop <i>object</i> and <i>value</i> from the stack as
the types <code>ptr</code> and <code>int32</code> respectively.
Store <i>value</i> at <i>object + N</i>.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull_n 1, padd_offset_n 1 N, iwrite</i>.<p/>

This instruction can also be used to write values of type
<code>uint32</code>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="pwrite_field" group="Object handling">
<operation>Write <code>int32</code> field</operation>

<format>pwrite_field<fsep/>N[1]</format>
<dformat>{pwrite_field}<fsep/>N</dformat>

<form name="pwrite_field" code="COP_PWRITE_FIELD"/>

<before>..., object, value</before>
<after>...</after>

<description>Pop <i>object</i> and <i>value</i> from the stack
as type <code>ptr</code>.  Store <i>value</i> at
<i>object + N</i>.</description>

<notes>If the offset <i>N</i> is greater than 255, then use
the sequence <i>cknull_n 1, padd_offset_n 1 N, pwrite</i>.<p/>

This instruction must not be confused with <i>iwrite_field</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of memory space on all
platforms.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="pread_this" group="Object handling">
<operation>Read <code>ptr</code> field from <code>this</code></operation>

<format>pread_this<fsep/>N[1]</format>
<dformat>{pread_this}<fsep/>N</dformat>

<form name="pread_this" code="COP_PREAD_THIS"/>

<before>...</before>
<after>..., value</after>

<description>Retrieve offset 0 from the frame as <i>object</i>,
of type <code>ptr</code>.  Fetch the <code>ptr</code> value at
<i>object + N</i>, and push it onto the stack.</description>

<notes>This instruction is used to optimise the sequence
<i>pload_0, pread_field N</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="iread_this" group="Object handling">
<operation>Read <code>int32</code> field from
<code>this</code></operation>

<format>iread_this<fsep/>N[1]</format>
<dformat>{iread_this}<fsep/>N</dformat>

<form name="iread_this" code="COP_IREAD_THIS"/>

<before>...</before>
<after>..., value</after>

<description>Retrieve offset 0 from the frame as <i>object</i>,
of type <code>ptr</code>.  Fetch the <code>int32</code> value at
<i>object + N</i>, and push it onto the stack.</description>

<notes>This instruction is used to optimise the sequence
<i>pload_0, iread_field N</i>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>object</i> is <code>null</code>.</exception>
</exceptions>
</opcode>
<opcode name="castclass" group="Object handling">
<operation>Cast an object to a new class</operation>

<format>castclass<fsep/>class</format>
<dformat>{castclass}<fsep/>class</dformat>

<form name="castclass" code="COP_CASTCLASS"/>

<before>..., object</before>
<after>..., object</after>

<description>Inspect the <i>object</i> on the top of the stack.
If <i>object</i> is <code>null</code> or its class inherits
from <i>class</i>, execution continues with the next instruction.
Otherwise, <code>System.InvalidCastException</code>
is thrown.</description>

<notes>The <i>class</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

This instruction can only be used to test for normal inheritance.
Use <i>castinterface</i> to cast objects to interfaces.</notes>

<exceptions>
<exception name="System.InvalidCastException">Raised if
<i>object</i>'s class does not inherit from <i>class</i>.</exception>
</exceptions>
</opcode>
<opcode name="isinst" group="Object handling">
<operation>Determine if an object is an instance of a class</operation>

<format>isinst<fsep/>class</format>
<dformat>{isinst}<fsep/>class</dformat>

<form name="isinst" code="COP_ISINST"/>

<before>..., object</before>
<after>..., newobject</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
If <i>object</i> is <code>null</code> or its class inherits
from <i>class</i>, then set <i>newobject</i> to <i>object</i>.
Otherwise, set <i>newobject</i> to <code>null</code>.  Push
<i>newobject</i> onto the stack.</description>

<notes>The <i>class</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

This instruction can only be used to test for normal inheritance.
Use <i>isinterface</i> to test for interface membership.</notes>
</opcode>
<opcode name="castinterface" group="Object handling">
<operation>Cast an object to a new interface</operation>

<format>castinterface<fsep/>interface</format>
<dformat>{castinterface}<fsep/>interface</dformat>

<form name="castinterface" code="COP_CASTINTERFACE"/>

<before>..., object</before>
<after>..., object</after>

<description>Inspect the <i>object</i> on the top of the stack.
If <i>object</i> is <code>null</code> or its class implements
<i>interface</i>, execution continues with the next instruction.
Otherwise, <code>System.InvalidCastException</code>
is thrown.</description>

<notes>The <i>interface</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

This instruction can only be used to test for interface inheritance.
Use <i>castclass</i> to cast objects to parent classes.</notes>

<exceptions>
<exception name="System.InvalidCastException">Raised if
<i>object</i>'s class does not implement <i>interface</i>.</exception>
</exceptions>
</opcode>
<opcode name="isinterface" group="Object handling">
<operation>Determine if an object is an instance of
an interface</operation>

<format>isinterface<fsep/>interface</format>
<dformat>{isinterface}<fsep/>interface</dformat>

<form name="isinterface" code="COP_ISINTERFACE"/>

<before>..., object</before>
<after>..., newobject</after>

<description>Pop <i>object</i> from the stack as type <code>ptr</code>.
If <i>object</i> is <code>null</code> or its class implements
<i>interface</i>, then set <i>newobject</i> to <i>object</i>.
Otherwise, set <i>newobject</i> to <code>null</code>.  Push
<i>newobject</i> onto the stack.</description>

<notes>The <i>interface</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

This instruction can only be used to test for interface inheritance.
Use <i>isinst</i> to test for normal inheritance.</notes>
</opcode>
<opcode name="get_static" group="Object handling">
<operation>Get a pointer to the static data area of a class</operation>

<format>get_static<fsep/>class</format>
<dformat>{get_static}<fsep/>class</dformat>

<form name="get_static" code="COP_GET_STATIC"/>

<before>...</before>
<after>..., pointer</after>

<description>If <i>class</i> currently has a static data area,
then push the data area's <i>pointer</i> onto the stack.
Otherwise, allocate a new static data area for <i>class</i>
and push it onto the stack.</description>

<notes>The <i>class</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

This instruction is used in combination with the
<i>*read</i> and <i>*write</i> instructions to access static
fields within a class.</notes>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the static data
area.</exception>
</exceptions>
</opcode>
<opcode name="new" group="Object handling">
<operation>Allocate an instance of the current class</operation>

<format>new</format>
<dformat>{new}</dformat>

<form name="new" code="COP_NEW"/>

<before>...</before>
<after>..., pointer</after>

<description>Allocates an instance of the class associated with
the currently executing method, and pushes a <i>pointer</i> to
this instance onto the stack.</description>

<notes>This instruction is used inside constructors to allocate
memory for a new object.  The fields of the new object are
initialized to zero.</notes>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the object.</exception>
</exceptions>
</opcode>
<opcode name="new_value" group="Object handling">
<operation>Allocate a new value type instance and push it down</operation>

<format>new_value<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>new_value<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{new_value}<fsep/>N<fsep/>M</dformat>

<form name="new_value" code="COP_NEW_VALUE"/>

<before>..., val1, ..., valN</before>
<after>..., value, pointer, val1, ..., valN</after>

<description>Creates a new value type instance of <i>M</i>
stack words in size and places it, and a <i>pointer</i> to it,
<i>N</i> positions down the stack.  The fields of the new
instance are initialized to zero.  <i>N == 0</i> to place
the new instance at the top of the stack.</description>

<notes>This instruction is used inside value type constructors to
insert the return value and the <code>this</code> pointer into the
stack prior to running the main constructor code.</notes>
</opcode>
<opcode name="ldstr" group="Constant loading">
<operation>Load a string constant onto the stack</operation>

<format>ldstr<fsep/>token[4]</format>
<dformat>{ldstr}<fsep/>token</dformat>

<form name="ldstr" code="COP_LDSTR"/>

<before>...</before>
<after>..., string</after>

<description>Loads the string <i>token</i> from the current
method's image and pushes the corresponding <i>string</i>
object onto the stack.</description>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the string.</exception>
</exceptions>
</opcode>
<opcode name="ldtoken" group="Miscellaneous instructions">
<operation>Load a token pointer onto the stack</operation>

<format>ldtoken<fsep/>pointer</format>
<dformat>{ldtoken}<fsep/>pointer</dformat>

<form name="ldtoken" code="COP_LDTOKEN"/>

<before>...</before>
<after>..., pointer</after>

<description>Push <i>pointer</i> onto the stack as a
<code>ptr</code> value.</description>

<notes>The <i>pointer</i> value is a native pointer to the token
descriptor, which may 32 or 64 bits in size.<p/>

This instruction is used to load type, field, and method
descriptors onto the stack as handle instances.</notes>
</opcode>
<opcode name="box" group="Object handling">
<operation>Box a value type instance</operation>

<format>box<fsep/>N[1]<fsep/>class</format>
<format>wide<fsep/>box<fsep/>N[4]<fsep/>class</format>
<dformat>{box}<fsep/>N<fsep/>class</dformat>

<form name="box" code="COP_BOX"/>

<before>..., value</before>
<after>..., object</after>

<description>Pop the managed <i>value</i> from the stack.  The size
of <i>value</i> is <i>N</i> stack words.  Allocate a new <i>object</i>
instance of <i>class</i>, copy <i>value</i> into it, and then push
<i>object</i> onto the stack.</description>

<notes>The <i>class</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.<p/>

There is no <i>unbox</i> instruction.  The object layout is defined
so that an object reference can also be used as a managed pointer
to the contents of the object.</notes>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the new object.</exception>
</exceptions>
</opcode>
<opcode name="box_ptr" group="Object handling">
<operation>Box a value type instance at a pointer</operation>

<format>box_ptr<fsep/>N[1]<fsep/>class</format>
<format>wide<fsep/>box_ptr<fsep/>N[4]<fsep/>class</format>
<dformat>{box_ptr}<fsep/>N<fsep/>class</dformat>

<form name="box_ptr" code="COP_BOX_PTR"/>

<before>..., pointer</before>
<after>..., object</after>

<description>Pop <i>pointer</i> from the stack as type <code>ptr</code>.
Allocate a new <i>object</i> of <i>N</i> bytes in size as an instance
of <i>class</i>.  Copy the <i>N</i> bytes of memory from <i>pointer</i>
to the object.  Push <i>object</i> onto the stack.</description>

<notes>The <i>class</i> value is a native pointer to the class
descriptor, which may 32 or 64 bits in size.</notes>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the new object.</exception>
</exceptions>
</opcode>
<opcode name="memcpy" group="Miscellaneous instructions">
<operation>Copy a fixed-size block of non-overlapping memory</operation>

<format>memcpy<fsep/>N[1]</format>
<format>wide<fsep/>memcpy<fsep/>N[4]</format>
<dformat>{memcpy}<fsep/>N</dformat>

<form name="memcpy" code="COP_MEMCPY"/>

<before>..., dest, src</before>
<after>...</after>

<description>Pop <i>dest</i> and <i>src</i> from the stack as type
<code>ptr</code>.  Copy <i>N</i> bytes of memory from <i>src</i>
to <i>dest</i>.</description>

<notes>It is assumed that the source and destination regions do
not overlap.<p/>

This instruction is typically used to copy value type instances
from one location to another.<p/>

Use <i>memmove</i> for overlapping memory regions, and for regions
that do not have a fixed size.</notes>
</opcode>
<opcode name="memmove" group="Miscellaneous instructions">
<operation>Move a block of memory</operation>

<format>memmove</format>
<dformat>{memmove}</dformat>

<form name="memmove" code="COP_MEMMOVE"/>

<before>..., dest, src, length</before>
<after>...</after>

<description>Pop <i>dest</i>, <i>src</i>, and <i>length</i>
from the stack as the types <code>ptr</code>, <code>ptr</code>,
and <code>uint32</code> respectively.  Move <i>length</i> bytes
of memory from <i>src</i> to <i>dest</i>.</description>

<notes>If the source and destination regions overlap, this instruction
will guarantee to produce the correct result.</notes>
</opcode>
<opcode name="memzero" group="Miscellaneous instructions">
<operation>Fill a fixed-size block of memory with zeroes</operation>

<format>memzero<fsep/>N[1]</format>
<format>wide<fsep/>memzero<fsep/>N[4]</format>
<dformat>{memzero}<fsep/>N</dformat>

<form name="memzero" code="COP_MEMZERO"/>

<before>..., dest</before>
<after>...</after>

<description>Pop <i>dest</i> from the stack as type
<code>ptr</code>.  Fill <i>N</i> bytes of memory at <i>dest</i>
with zero bytes.</description>

<notes>This instruction is typically used to initialize value type
instances.<p/>

Use <i>memset</i> if the region does not have a fixed size, or the
fill value is something other than zero.</notes>
</opcode>
<opcode name="memset" group="Miscellaneous instructions">
<operation>Fill a block of memory with a byte value</operation>

<format>memset</format>
<dformat>{memset}</dformat>

<form name="memset" code="COP_MEMSET"/>

<before>..., dest, value, length</before>
<after>...</after>

<description>Pop <i>dest</i>, <i>value</i>, and <i>length</i>
from the stack as the types <code>ptr</code>, <code>int32</code>,
and <code>uint32</code>.  Fill <i>length</i> bytes of memory at
<i>dest</i> with <i>value</i>.</description>
</opcode>
<opcode name="lread_elem" group="Array handling">
<operation>Read <code>int64</code> value from array</operation>

<format>prefix<fsep/>lread_elem</format>
<dformat>{lread_elem}</dformat>

<form name="lread_elem" code="COP_PREFIX_LREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the <code>int64</code> value from position
<i>index</i> in <i>array</i>, and push it onto the stack.</description>

<notes>This instruction can also be used to read values of
type <code>uint64</code>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="fread_elem" group="Array handling">
<operation>Read <code>float32</code> value from array</operation>

<format>prefix<fsep/>fread_elem</format>
<dformat>{fread_elem}</dformat>

<form name="fread_elem" code="COP_PREFIX_FREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the <code>float32</code> value from position
<i>index</i> in <i>array</i>, extend it to <code>native float</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="dread_elem" group="Array handling">
<operation>Read <code>float64</code> value from array</operation>

<format>prefix<fsep/>dread_elem</format>
<dformat>{dread_elem}</dformat>

<form name="dread_elem" code="COP_PREFIX_DREAD_ELEM"/>

<before>..., array, index</before>
<after>..., value</after>

<description>Pop <i>array</i> and <i>index</i> from
the stack as the types <code>ptr</code> and <code>int32</code>
respectively.  Load the <code>float64</code> value from position
<i>index</i> in <i>array</i>, extend it to <code>native float</code>,
and push it onto the stack.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="lwrite_elem" group="Array handling">
<operation>Write <code>int64</code> value to array</operation>

<format>prefix<fsep/>lwrite_elem</format>
<dformat>{lwrite_elem}</dformat>

<form name="lwrite_elem" code="COP_PREFIX_LWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int64</code> respectively.
The <i>value</i> is written at position <i>index</i>
in <i>array</i>.</description>

<notes>This instruction can also be used to write values of
type <code>uint64</code>.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="fwrite_elem" group="Array handling">
<operation>Write <code>float32</code> value to array</operation>

<format>prefix<fsep/>fwrite_elem</format>
<dformat>{fwrite_elem}</dformat>

<form name="fwrite_elem" code="COP_PREFIX_FWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>native float</code> respectively.
The <i>value</i> is truncated to <code>float32</code> and written
at position <i>index</i> in <i>array</i>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="dwrite_elem" group="Array handling">
<operation>Write <code>float64</code> value to array</operation>

<format>prefix<fsep/>dwrite_elem</format>
<dformat>{dwrite_elem}</dformat>

<form name="dwrite_elem" code="COP_PREFIX_DWRITE_ELEM"/>

<before>..., array, index, value</before>
<after>...</after>

<description>Pop <i>array</i>, <i>index</i>, and
<i>value</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>native float</code> respectively.
The <i>value</i> is truncated to <code>float64</code> and written
at position <i>index</i> in <i>array</i>.</description>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index</i> is not within the array's bounds.</exception>
</exceptions>
</opcode>
<opcode name="get2d" group="Array handling">
<operation>Prepare for a two-dimensional array get operation</operation>

<format>prefix<fsep/>get2d</format>
<dformat>{get2d}</dformat>

<form name="get2d" code="COP_PREFIX_GET2D"/>

<before>..., array, index1, index2</before>
<after>..., address</after>

<description>Pop <i>array</i>, <i>index1</i>, and
<i>index2</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int32</code> respectively.
The <i>address</i> of <i>array[index1, index2]</i> is pushed onto
the stack as type <code>ptr</code>.</description>

<notes>This instruction is normally followed by a <i>*read</i>
instruction to read the contents of the array element.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index1</i> or <i>index2</i> is not within the array's
bounds.</exception>
</exceptions>
</opcode>
<opcode name="set2d" group="Array handling">
<operation>Prepare for a two-dimensional array set operation</operation>

<format>prefix<fsep/>set2d<fsep/>N[4]</format>
<dformat>{set2d}<fsep/>N</dformat>

<form name="set2d" code="COP_PREFIX_SET2D"/>

<before>..., array, index1, index2, value</before>
<after>..., address, value</after>

<description>Remove <i>array</i>, <i>index1</i>, and
<i>index2</i> from the stack as the types <code>ptr</code>,
<code>int32</code>, and <code>int32</code> respectively.
The <i>address</i> of <i>array[index1, index2]</i> is pushed into
the stack as type <code>ptr</code> just below <i>value</i>.
The operand <i>N</i> indicates the number of stack words that
are occupied by <i>value</i>.</description>

<notes>This instruction is normally followed by a <i>*write</i>
instruction to write the contents of the array element.</notes>

<exceptions>
<exception name="System.NullReferenceException">Raised if
<i>array</i> is <code>null</code>.</exception>
<exception name="System.IndexOutOfRangeException">Raised if
<i>index1</i> or <i>index2</i> is not within the array's
bounds.</exception>
</exceptions>
</opcode>
<opcode name="mkrefany" group="Object handling">
<operation>Make a <code>typedref</code></operation>

<format>prefix<fsep/>mkrefany<fsep/>class</format>
<dformat>{mkrefany}<fsep/>class</dformat>

<form name="mkrefany" code="COP_PREFIX_MKREFANY"/>

<before>..., pointer</before>
<after>..., reference</after>

<description>Pop <i>pointer</i> from the stack as type
<code>ptr</code>.  Make a <code>typedref</code> <i>reference</i> from
<i>pointer</i> and <i>class</i>.  Push <i>reference</i> onto
the stack.</description>

<notes>The <i>class</i> is a native pointer, which may be either
32 or 64 bits in size, depending upon the platform.</notes>
</opcode>
<opcode name="refanyval" group="Object handling">
<operation>Extract the value from a <code>typedref</code></operation>

<format>prefix<fsep/>refanyval<fsep/>class</format>
<dformat>{refanyval}<fsep/>class</dformat>

<form name="refanyval" code="COP_PREFIX_REFANYVAL"/>

<before>..., reference</before>
<after>..., pointer</after>

<description>Pop <i>reference</i> from the stack as type
<code>typedref</code>.  If <i>reference</i> refers to an instance
of <i>class</i>, then extract the <i>pointer</i> from the
<i>reference</i> and push it onto the stack.  Otherwise, throw
<code>System.InvalidCastException</code>.</description>

<notes>The <i>class</i> is a native pointer, which may be either
32 or 64 bits in size, depending upon the platform.</notes>

<exceptions>
<exception name="System.InvalidCastException">Raised if
<i>reference</i> does not refer to an instance of <i>class</i>.
</exception>
</exceptions>
</opcode>
<opcode name="refanytype" group="Object handling">
<operation>Extract the type from a <code>typedref</code></operation>

<format>prefix<fsep/>refanytype</format>
<dformat>{refanytype}</dformat>

<form name="refanytype" code="COP_PREFIX_REFANYTYPE"/>

<before>..., reference</before>
<after>..., type</after>

<description>Pop <i>reference</i> from the stack as type
<code>typedref</code>.  Extract the <i>type</i> from
<i>reference</i> and push it onto the stack.</description>
</opcode>
<opcode name="thread_static" group="Object handling">
<operation>Get a pointer to the thread-static data area</operation>

<format>prefix<fsep/>thread_static<fsep/>slot[4]<fsep/>size[4]</format>
<dformat>{thread_static}<fsep/>slot<fsep/>size</dformat>

<form name="thread_static" code="COP_PREFIX_THREAD_STATIC"/>

<before>...</before>
<after>..., ptr</after>

<description>Push a pointer to the current thread's static
data area onto the stack.  The value <i>slot</i> indicates which
slot to retrieve the pointer from.  The value <i>size</i> indicates
the size of the data object if the slot is currently empty.</description>
</opcode>
<opcode name="dup" group="Stack manipulation">
<operation>Duplicate the top of stack</operation>

<format>dup</format>
<dformat>{dup}</dformat>

<form name="dup" code="COP_DUP"/>

<before>..., value</before>
<after>..., value, value</after>

<description>Pop the single-word <i>value</i> from
the stack, and then push it twice.</description>
</opcode>
<opcode name="dup2" group="Stack manipulation">
<operation>Duplicate the top two stack words</operation>

<format>dup2</format>
<dformat>{dup2}</dformat>

<form name="dup2" code="COP_DUP2"/>

<before>..., value1, value2</before>
<after>..., value1, value2, value1, value2</after>

<description>Pop the words <i>value1</i> and <i>value2</i> from
the stack and then push them twice.</description>
</opcode>
<opcode name="dup_n" group="Stack manipulation">
<operation>Duplicate the top <i>N</i> stack words</operation>

<format>dup_n<fsep/>N[1]</format>
<format>wide<fsep/>dup_n<fsep/>N[4]</format>
<dformat>{dup_n}<fsep/>N</dformat>

<form name="dup_n" code="COP_DUP_N"/>

<before>..., value1, ..., valueN</before>
<after>..., value1, ..., valueN, value1, ..., valueN</after>

<description>Pop the top <i>N</i> words from the stack and then
push them twice.</description>

<notes>This is typically used for value type instances that are larger
than 2 words in size.</notes>
</opcode>
<opcode name="dup_word_n" group="Stack manipulation">
<operation>Duplicate a stack word that is <i>N</i> words
down the stack</operation>

<format>dup_word_n<fsep/>N[1]</format>
<format>wide<fsep/>dup_word_n<fsep/>N[4]</format>
<dformat>{dup_word_n}<fsep/>N</dformat>

<form name="dup_word_n" code="COP_DUP_WORD_N"/>

<before>..., value, word1, ..., wordN</before>
<after>..., value, word1, ..., wordN, value</after>

<description>Retrieve the <i>value</i> that is <i>N</i> words
down the stack and push it onto the top of the stack.</description>
</opcode>
<opcode name="pop" group="Stack manipulation">
<operation>Pop the top-most word from the stack</operation>

<format>pop</format>
<dformat>{pop}</dformat>

<form name="pop" code="COP_POP"/>

<before>..., value</before>
<after>...</after>

<description>Pop the single-word <i>value</i> from
the stack.</description>
</opcode>
<opcode name="pop2" group="Stack manipulation">
<operation>Pop the top two words from the stack</operation>

<format>pop2</format>
<dformat>{pop2}</dformat>

<form name="pop2" code="COP_POP2"/>

<before>..., value1, value2</before>
<after>...</after>

<description>Pop the two stack words <i>value1</i> and <i>value2</i>
from the stack.</description>
</opcode>
<opcode name="pop_n" group="Stack manipulation">
<operation>Pop the top <i>N</i> words from the stack</operation>

<format>pop_n<fsep/>N[1]</format>
<format>wide<fsep/>pop_n<fsep/>N[4]</format>
<dformat>{pop_n}<fsep/>N</dformat>

<form name="pop_n" code="COP_POP_N"/>

<before>..., value1, ..., valueN</before>
<after>...</after>

<description>Pop the top <i>N</i> stack words
from the stack.</description>
</opcode>
<opcode name="squash" group="Stack manipulation">
<operation>Squash a number of words out of the stack</operation>

<format>squash<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>squash<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{squash}<fsep/>N<fsep/>M</dformat>

<form name="squash" code="COP_SQUASH"/>

<before>..., word1, ..., wordM, value1, ..., valueN</before>
<after>..., value1, ..., valueN</after>

<description>Remove the <i>M</i> words from the stack,
<i>N</i> words down the stack.</description>
</opcode>
<opcode name="ckheight" group="Stack manipulation">
<operation>Check the height of the stack</operation>

<format>ckheight<fsep/>0<fsep/>0<fsep/>0<fsep/>0</format>
<dformat>{ckheight}<fsep/>0</dformat>

<form name="ckheight" code="COP_CKHEIGHT"/>

<description>Check that the stack has at least 8 words of
space available for pushing values.</description>

<notes>This instruction is used at the start of a method to
check that that there is sufficient stack space to hold the
local variables and temporary stack values used by the method.<p/>

The opcode is followed by 4 zero bytes so that this instruction
has the same length as <i>ckheight_n</i>.  This makes it easier
to back-patch the height after translating the method.</notes>

<exceptions>
<exception name="System.StackOverflowException">Raised if
there is insufficient space available on the stack.</exception>
</exceptions>
</opcode>
<opcode name="ckheight_n" group="Stack manipulation">
<operation>Check the height of the stack for <i>N</i>
words of available space</operation>

<format>ckheight_n<fsep/>N[4]</format>
<dformat>{ckheight_n}<fsep/>N</dformat>

<form name="ckheight_n" code="COP_CKHEIGHT_N"/>

<description>Check that the stack has at least <i>N</i> words of
space available for pushing values.</description>

<notes>This instruction is used at the start of a method to
check that that there is sufficient stack space to hold the
local variables and temporary stack values used by the method.</notes>

<exceptions>
<exception name="System.StackOverflowException">Raised if
there is insufficient space available on the stack.</exception>
</exceptions>
</opcode>
<opcode name="set_num_args" group="Call management instructions">
<operation>Set the number of arguments for the current method</operation>

<format>set_num_args<fsep/>N[1]</format>
<format>wide<fsep/>set_num_args<fsep/>N[4]</format>
<dformat>{set_num_args}<fsep/>N</dformat>

<form name="set_num_args" code="COP_SET_NUM_ARGS"/>

<description>Set the frame pointer for the current method to
the address of the <i>N</i>'th word down the stack.</description>

<notes>This is typically the first instruction in a method, which
sets up the local variable frame.</notes>
</opcode>
<opcode name="local_alloc" group="Stack manipulation">
<operation>Allocate local stack space</operation>

<format>prefix<fsep/>local_alloc</format>
<dformat>{local_alloc}</dformat>

<form name="local_alloc" code="COP_PREFIX_LOCAL_ALLOC"/>

<before>..., size</before>
<after>..., pointer</after>

<description>Pop <i>size</i> from the stack as type <code>uint</code>,
and then push a <i>pointer</i> to a block of memory of <i>size</i> bytes
in size.</description>

<notes>The block is not expected to last beyond the lifetime of
the current method, but implementations may allocate longer-term
memory if it is difficult to do direct stack allocation.</notes>

<exceptions>
<exception name="System.OutOfMemoryException">Raised if
there is insufficient memory to allocate the block.</exception>
</exceptions>
</opcode>
<opcode name="iload_&lt;n&gt;" group="Local variable handling">
<operation>Load <code>int32</code> variable <i>n</i>
onto the stack</operation>

<format>iload_&lt;n&gt;</format>
<dformat>{iload_&lt;n&gt;}</dformat>

<form name="iload_0" code="COP_ILOAD_0"/>
<form name="iload_1" code="COP_ILOAD_1"/>
<form name="iload_2" code="COP_ILOAD_2"/>
<form name="iload_3" code="COP_ILOAD_3"/>

<before>...</before>
<after>..., value</after>

<description>Load the <code>int32</code> variable from position
<i>n</i> in the local variable frame and push its <i>value</i>
onto the stack.</description>

<notes>These instructions can also be used to load variables
of type <code>uint32</code> onto the stack.</notes>
</opcode>
<opcode name="pload_&lt;n&gt;" group="Local variable handling">
<operation>Load <code>ptr</code> variable <i>n</i>
onto the stack</operation>

<format>pload_&lt;n&gt;</format>
<dformat>{pload_&lt;n&gt;}</dformat>

<form name="pload_0" code="COP_PLOAD_0"/>
<form name="pload_1" code="COP_PLOAD_1"/>
<form name="pload_2" code="COP_PLOAD_2"/>
<form name="pload_3" code="COP_PLOAD_3"/>

<before>...</before>
<after>..., value</after>

<description>Load the <code>ptr</code> variable from position
<i>n</i> in the local variable frame and push its <i>value</i>
onto the stack.</description>

<notes>These instructions must not be confused with the
<i>iload_&lt;n&gt;</i> instructions.  Values of type
<code>int32</code> and <code>ptr</code> do not necessarily
occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="iload" group="Local variable handling">
<operation>Load <code>int32</code> variable
onto the stack</operation>

<format>iload<fsep/>N[1]</format>
<format>wide<fsep/>iload<fsep/>N[4]</format>
<dformat>{iload}<fsep/>N</dformat>

<form name="iload" code="COP_ILOAD"/>

<before>...</before>
<after>..., value</after>

<description>Load the <code>int32</code> variable from position
<i>N</i> in the local variable frame and push its <i>value</i>
onto the stack.</description>

<notes>This instruction can also be used to load variables
of type <code>uint32</code> onto the stack.</notes>
</opcode>
<opcode name="pload" group="Local variable handling">
<operation>Load <code>ptr</code> variable
onto the stack</operation>

<format>pload<fsep/>N[1]</format>
<format>wide<fsep/>pload<fsep/>N[4]</format>
<dformat>{pload}<fsep/>N</dformat>

<form name="pload" code="COP_PLOAD"/>

<before>...</before>
<after>..., value</after>

<description>Load the <code>ptr</code> variable from position
<i>N</i> in the local variable frame and push its <i>value</i>
onto the stack.</description>

<notes>This instruction must not be confused with <i>iload</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="istore_&lt;n&gt;" group="Local variable handling">
<operation>Store the top of stack into <code>int32</code>
variable <i>n</i></operation>

<format>istore_&lt;n&gt;</format>
<dformat>{istore_&lt;n&gt;}</dformat>

<form name="istore_0" code="COP_ISTORE_0"/>
<form name="istore_1" code="COP_ISTORE_1"/>
<form name="istore_2" code="COP_ISTORE_2"/>
<form name="istore_3" code="COP_ISTORE_3"/>

<before>..., value</before>
<after>...</after>

<description>Pop <i>value</i> from the stack as type <code>int32</code>
and store it at position <i>n</i> in the local variable frame.
</description>

<notes>These instructions can also be used to store to variables
of type <code>uint32</code>.</notes>
</opcode>
<opcode name="pstore_&lt;n&gt;" group="Local variable handling">
<operation>Store the top of stack into <code>ptr</code>
variable <i>n</i></operation>

<format>pstore_&lt;n&gt;</format>
<dformat>{pstore_&lt;n&gt;}</dformat>

<form name="pstore_0" code="COP_PSTORE_0"/>
<form name="pstore_1" code="COP_PSTORE_1"/>
<form name="pstore_2" code="COP_PSTORE_2"/>
<form name="pstore_3" code="COP_PSTORE_3"/>

<before>..., value</before>
<after>...</after>

<description>Pop <i>value</i> from the stack as type <code>ptr</code>
and store it at position <i>n</i> in the local variable frame.
</description>

<notes>These instructions must not be confused with the
<i>istore_&lt;n&gt;</i> instructions.  Values of type
<code>int32</code> and <code>ptr</code> do not necessarily
occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="istore" group="Local variable handling">
<operation>Store the top of stack into <code>int32</code>
variable</operation>

<format>istore<fsep/>N[1]</format>
<format>wide<fsep/>istore<fsep/>N[4]</format>
<dformat>{istore}<fsep/>N</dformat>

<form name="istore" code="COP_ISTORE"/>

<before>..., value</before>
<after>...</after>

<description>Pop <i>value</i> from the stack as type <code>int32</code>
and store it at position <i>N</i> in the local variable frame.
</description>

<notes>This instruction can also be used to store to variables
of type <code>uint32</code>.</notes>
</opcode>
<opcode name="pstore" group="Local variable handling">
<operation>Store the top of stack into <code>ptr</code>
variable</operation>

<format>pstore<fsep/>N[1]</format>
<format>wide<fsep/>pstore<fsep/>N[4]</format>
<dformat>{pstore}<fsep/>N</dformat>

<form name="pstore" code="COP_PSTORE"/>

<before>..., value</before>
<after>...</after>

<description>Pop <i>value</i> from the stack as type <code>ptr</code>
and store it at position <i>N</i> in the local variable frame.
</description>

<notes>This instructions must not be confused with <i>istore</i>.
Values of type <code>int32</code> and <code>ptr</code> do not
necessarily occupy the same amount of space in a stack word on
all platforms.</notes>
</opcode>
<opcode name="mload" group="Local variable handling">
<operation>Load multiple stack words from a variable
onto the stack</operation>

<format>mload<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>mload<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{mload}<fsep/>N<fsep/>M</dformat>

<form name="mload" code="COP_MLOAD"/>

<before>...</before>
<after>..., value1, ..., valueM</after>

<description>Load the <i>M</i> stack words from position
<i>N</i> in the local variable frame and push them
onto the stack.</description>
</opcode>
<opcode name="mstore" group="Local variable handling">
<operation>Store multiple stack words from the stack
to a variable</operation>

<format>mstore<fsep/>N[1]<fsep/>M[1]</format>
<format>wide<fsep/>mstore<fsep/>N[4]<fsep/>M[4]</format>
<dformat>{mstore}<fsep/>N<fsep/>M</dformat>

<form name="mstore" code="COP_MSTORE"/>

<before>..., value1, ..., valueM</before>
<after>...</after>

<description>Pop the <i>M</i> stack words from the top of
the stack and store them at position <i>N</i> in the local
variable frame.</description>
</opcode>
<opcode name="waddr" group="Local variable handling">
<operation>Load the address of a variable onto the stack</operation>

<format>waddr<fsep/>N[1]</format>
<format>wide<fsep/>waddr<fsep/>N[4]</format>
<dformat>{waddr}<fsep/>N</dformat>

<form name="waddr" code="COP_WADDR"/>

<before>...</before>
<after>..., pointer</after>

<description>Set <i>pointer</i> to the address of the word at
position <i>N</i> in the local variable frame.  Push <i>pointer</i>
onto the stack as type <code>ptr</code>.</description>
</opcode>
<opcode name="maddr" group="Local variable handling">
<operation>Load the address of a stack word onto the stack</operation>

<format>maddr<fsep/>N[1]</format>
<format>wide<fsep/>maddr<fsep/>N[4]</format>
<dformat>{maddr}<fsep/>N</dformat>

<form name="maddr" code="COP_MADDR"/>

<before>...</before>
<after>..., pointer</after>

<description>Set <i>pointer</i> to the address of the word at
<i>N</i> positions down the stack.  Push <i>pointer</i>
onto the stack as type <code>ptr</code>.  <i>N == 1</i> indicates
the address of the top-most stack word prior to the operation.
</description>

<notes>This instruction is typically used to get the address of
a managed value on the stack, so that the value can be manipulated
with pointer operations.</notes>
</opcode>
<opcode name="bload" group="Local variable handling">
<operation>Load <code>uint8</code> variable
onto the stack</operation>

<format>bload<fsep/>N[1]</format>
<dformat>{bload}<fsep/>N</dformat>

<form name="bload" code="COP_BLOAD"/>

<before>...</before>
<after>..., value</after>

<description>Load the <code>uint8</code> variable from position
<i>N</i> in the local variable frame and push its <i>value</i>
onto the stack.</description>

<notes>This instruction is a quicker variant of
<i>waddr N, bread</i>.<p/>

This instruction can also be used to load <code>bool</code>
values onto the stack.</notes>
</opcode>
<opcode name="bstore" group="Local variable handling">
<operation>Store the top of stack into <code>uint8</code>
variable</operation>

<format>bstore<fsep/>N[1]</format>
<dformat>{bstore}<fsep/>N</dformat>

<form name="bstore" code="COP_BSTORE"/>

<before>..., value</before>
<after>...</after>

<description>Pop <i>value</i> from the stack as type <code>int32</code>
and store it at position <i>N</i> in the local variable frame,
truncated to the type <code>uint8</code>.
</description>

<notes>This instruction is a quicker variant of
<i>waddr N, bwrite_r</i>.<p/>

This instruction can also be used to store <code>bool</code>
values from the stack.</notes>
</opcode>
<opcode name="bfixup" group="Local variable handling">
<operation>Fix up <code>int8</code> variable</operation>

<format>bfixup<fsep/>N[1]</format>
<format>wide<fsep/>bfixup<fsep/>N[4]</format>
<dformat>{bfixup}<fsep/>N</dformat>

<form name="bfixup" code="COP_BFIXUP"/>

<description>Retrieve the contents of position <i>N</i> in the
local variable frame, truncate the value to 8 bits and write it
back to the same variable.  The destination is aligned at the
start of the stack word that contains the variable.</description>

<notes>This instruction is used to align <code>int8</code> and
<code>uint8</code> values that were passed as arguments to the
current method.<p/>

The result is guaranteed to be aligned on the start of a stack
word so that <i>waddr M</i> will push the correct address of
the byte.<p/>

This instruction is not normally required on little-endian platforms,
but it is definitely required on big-endian platforms.<p/>

The contents of an <code>int8</code> argument can be fetched
using <i>waddr N, bread</i> once <i>bfixup</i> has been used to
align its contents.</notes>
</opcode>
<opcode name="sfixup" group="Local variable handling">
<operation>Fix up <code>int16</code> variable</operation>

<format>sfixup<fsep/>N[1]</format>
<format>wide<fsep/>sfixup<fsep/>N[4]</format>
<dformat>{sfixup}<fsep/>N</dformat>

<form name="sfixup" code="COP_SFIXUP"/>

<description>Retrieve the contents of position <i>N</i> in the
local variable frame, truncate the value to 16 bits and write it
back to the same variable.  The destination is aligned at the
start of the stack word that contains the variable.</description>

<notes>This instruction is used to align <code>int16</code> and
<code>uint16</code> values that were passed as arguments to the
current method.<p/>

The result is guaranteed to be aligned on the start of a stack
word so that <i>waddr M</i> will push the correct address of
the 16 bit value.<p/>

This instruction is not normally required on little-endian platforms,
but it is definitely required on big-endian platforms.<p/>

The contents of an <code>int16</code> argument can be fetched
using <i>waddr N, sread</i> once <i>sfixup</i> has been used to
align its contents.</notes>
</opcode>
<opcode name="ffixup" group="Local variable handling">
<operation>Fix up <code>float32</code> variable</operation>

<format>ffixup<fsep/>N[1]</format>
<format>wide<fsep/>ffixup<fsep/>N[4]</format>
<dformat>{ffixup}<fsep/>N</dformat>

<form name="ffixup" code="COP_FFIXUP"/>

<description>Retrieve the contents of position <i>N</i> in the
local variable frame as type <code>native float</code>, truncate
the value to <code>float32</code> and write it back to the same
variable.  The destination is aligned at the start of the stack
word that contains the variable.</description>

<notes>This instruction is used to convert <code>native float</code>
values that were passed as arguments to the current method into
the <code>float32</code> for internal local variable access.<p/>

The result is guaranteed to be aligned on the start of a stack
word so that <i>waddr M</i> will push the correct address of
the <code>float32</code> value.<p/>

The contents of a <code>float32</code> argument can be fetched
using <i>waddr N, fread</i> once <i>ffixup</i> has been used to
convert its contents.</notes>
</opcode>
<opcode name="dfixup" group="Local variable handling">
<operation>Fix up <code>float64</code> variable</operation>

<format>dfixup<fsep/>N[1]</format>
<format>wide<fsep/>dfixup<fsep/>N[4]</format>
<dformat>{dfixup}<fsep/>N</dformat>

<form name="dfixup" code="COP_DFIXUP"/>

<description>Retrieve the contents of position <i>N</i> in the
local variable frame as type <code>native float</code>, truncate
the value to <code>float64</code> and write it back to the same
variable.  The destination is aligned at the start of the stack
word that contains the variable.</description>

<notes>This instruction is used to convert <code>native float</code>
values that were passed as arguments to the current method into
the <code>float64</code> for internal local variable access.<p/>

The result is guaranteed to be aligned on the start of a stack
word so that <i>waddr M</i> will push the correct address of
the <code>float64</code> value.<p/>

The contents of a <code>float64</code> argument can be fetched
using <i>waddr N, dread</i> once <i>dfixup</i> has been used to
convert its contents.</notes>
</opcode>
<opcode name="mk_local_1" group="Local variable handling">
<operation>Make one local variable slot</operation>

<format>mk_local_1</format>
<dformat>{mk_local_1}</dformat>

<form name="mk_local_1" code="COP_MK_LOCAL_1"/>

<before>...</before>
<after>..., zero</after>

<description>Push a single zeroed word onto the stack.</description>

<notes>This instruction is used to allocate local variable space
at the start of a method.</notes>
</opcode>
<opcode name="mk_local_2" group="Local variable handling">
<operation>Make two local variable slots</operation>

<format>mk_local_2</format>
<dformat>{mk_local_2}</dformat>

<form name="mk_local_2" code="COP_MK_LOCAL_2"/>

<before>...</before>
<after>..., zero1, zero2</after>

<description>Push two zeroed words onto the stack.</description>

<notes>This instruction is used to allocate local variable space
at the start of a method.</notes>
</opcode>
<opcode name="mk_local_3" group="Local variable handling">
<operation>Make three local variable slots</operation>

<format>mk_local_3</format>
<dformat>{mk_local_3}</dformat>

<form name="mk_local_3" code="COP_MK_LOCAL_3"/>

<before>...</before>
<after>..., zero1, zero2, zero3</after>

<description>Push three zeroed words onto the stack.</description>

<notes>This instruction is used to allocate local variable space
at the start of a method.</notes>
</opcode>
<opcode name="mk_local_n" group="Local variable handling">
<operation>Make <i>N</i> local variable slots</operation>

<format>mk_local_n<fsep/>N[1]</format>
<format>wide<fsep/>mk_local_n<fsep/>N[4]</format>
<dformat>{mk_local_n}<fsep/>N</dformat>

<form name="mk_local_n" code="COP_MK_LOCAL_N"/>

<before>...</before>
<after>..., zero1, ..., zeroN</after>

<description>Push <i>N</i> zeroed words onto the stack.</description>

<notes>This instruction is used to allocate local variable space
at the start of a method.</notes>
</opcode>
</srcdoc>
